vector<Clause> Engine::dload(cstr s) {
    vector<vector<vector<string>>> clause_asm_list = Toks::toSentences(s);
    vector<Clause> compiled_clauses;

    for (vector<vector<string>> unexpanded_clause : clause_asm_list) {
        // map<string, IntStack> refs;
        unordered_map<string, vector<int>> refs = unordered_map<string,vector<int>>();
        vector<cell> cells;
        vector<cell> goals;
        int k = 0;
        for (vector<string> clause_asm : Toks::mapExpand(unexpanded_clause)) {

            size_t line_len = clause_asm.size();

            goals.push_back(cell::reference(k++));
            cells.push_back(cell::argOffset(line_len));
            for (string cell_asm_code : clause_asm) {
                if (1 == cell_asm_code.length())
                    cell_asm_code = "c:" + cell_asm_code;
                string arg = cell_asm_code.substr(2);

                switch (cell_asm_code[0]) {
                case 'c':   cells.push_back(encode(cell::C_, arg));     k++; break;
                case 'n':   cells.push_back(encode(cell::N_, arg));     k++; break;
                case 'v':   put_ref(arg, refs, k);
                            cells.push_back(cell::tag(cell::BAD, k));   k++; break;
                case 'h':   refs[arg].push_back(k-1);
                            assert(k > 0);
                            cells[size_t(k-1)] = cell::argOffset(line_len-1);
                            goals.pop_back();                               break;
                default:    throw logic_error(cstr("FORGOTTEN=") + cell_asm_code);
                }
            }
        }
        linker(refs, cells, goals, compiled_clauses);
    }

    size_t clause_count = compiled_clauses.size();
    vector<Clause> all_clauses = vector<Clause>(clause_count);

    for (int i = 0; i < clause_count; i++) {
        all_clauses[i] = compiled_clauses[i];
    }

    return all_clauses;
 }

    void Engine::linker(unordered_map<string,vector<int>> refs,
                        vector<cell> &cells,
                        vector<cell> &goals,
                        vector<Clause> &compiled_clauses) {

        // final Iterator<IntStack> K = refs.values().iterator();
        // while (K.hasNext())
        
        for (auto kIs = refs.begin(); kIs != refs.end(); ++kIs) {
            //for (pair<string,vector<int>> kIs : refs) {
            vector<int> Is = kIs->second;
            if (Is.size() == 0)
                continue;
            assert(goals.size() > 0);

            // "finding the A among refs" [Engine.java]
            bool found = false;
            size_t leader = -1;
            for (size_t j = 0; j < Is.size(); ++j)
                if (/*cell::isArgOffset(cells[j])*/
                    cell::tagOf(cells[Is[j]]) == cell::A_) {
                    leader = Is[j];
                    found = true;
                    break;
                }

            if (!found) {
                // "for vars, first V others U" [Engine.java]
                leader = Is[0];
                for (size_t i = 0; i < Is.size(); ++i)
                    if (Is[i] == leader)
                        cells[Is[i]] = cell::tag(cell::V_, Is[i]);
                    else
                        cells[Is[i]] = cell::tag(cell::U_, leader);
            }
            else {
                for (size_t i = 0; i < Is.size(); ++i) {
                    if (Is[i] == leader)
                        continue;
                    cells[Is[i]] = cell::tag(cell::R_, leader);
                }
            }
        }

        int neck;
        if (1 == goals.size())
            neck = int(cells.size());
        else
            neck = cell::detag(goals[1L]);

        Clause C = putClause(cells, goals, neck); // safe to pass all?

        int len = int(cells.size());

        compiled_clauses.push_back(C);
    }

    //    was iota(clause_list.begin(), clause_list.end(), 0);
    vector<size_t> Engine::toNums(vector<Clause> clauses) {
        size_t l = clauses.size();
        vector<size_t> cls = vector<size_t>(l);
        for (size_t i = 0; i < l; i++) {
            cls[i] = i;
        }
        return cls;
    }

 /**
  * Extracts a query - by convention of the form
  * goal(Vars):-body to be executed by the engine
  */
Clause Engine::getQuery() {
    return clauses[clauses.size() - 1];
}

/**
 * Returns the initial spine built from the query from which execution starts.
 */
Spine *Engine::init() {
    size_t base = heap_size();
    Clause G = getQuery();
    Spine *Q = new Spine(G.goal_refs, base, nullptr, trail.getTop(), 0, clause_list);

    spines.push_back(Q);
    return Q;
}

/**
 * answer - "Returns an answer as a Spine while recording in it
 * the top of the trail to allow the caller to retrieve
 * more answers by forcing backtracking."
 */
Spine* Engine::answer(int trail_top) {
    return new Spine(spines[0]->head, trail_top);
}

/**
 * hasClauses - "Detects availability of alternative clauses for the
 * top goal of this spine."
 */
bool Engine::hasClauses(Spine* S) {
    return S->last_clause_tried < S->unifiables.size();
}

/**
 * ask - "Retrieves an answer and ensures the engine can be resumed
 * by unwinding the trail of the query Spine.
 * Returns an external "human readable" representation of the answer.
 *
 * "A key element in the interpreter loop is to ensure that
 * after an Engine yields an answer, it can, if asked to,
 * resume execution and work on computing more answers. [...]
 * A variable 'query' of type Spine, contains the top of the trail
 * as it was before evaluation of the last goal,
 * up to where bindings of the variables will have to be undone,
 * before resuming execution. It also unpacks the actual answer term
 * (by calling the method exportTerm) to a tree representation of a term,
 * consisting of recursively embedded arrays hosting as leaves,
 * an external representation of symbols, numbers and variables." [HHG doc]
 */
Object Engine::ask() {
    query = yield_();
    if (nullptr == query)
        return Object();

    auto ans = answer(query->trail_top);

    auto res = ans->head;
    auto R = exportTerm(res);
    unwindTrail(query->trail_top);
    delete ans;

    // delete query;   // leaky to delete this?
    query = nullptr;

    return R;
}
/**
 * unwindTrail - "Removes binding for variable cells
 * above savedTop." [Engine.java]
 */
void Engine::unwindTrail(int savedTop) {
    while (savedTop < trail.getTop()) {
        cell href = trail.pop();
        int x = cell::detag(href);
        setRef(href, href);
    }
}

/**
 * popSpine - "Removes this spine from the spine stack and
 * resets trail and heap to where they were at its
 * creation time - while undoing variable binding
 * up to that point." [Engine.java]
 */
void Engine::popSpine() {

    Spine *G = spines.back();
    int new_base = int(G->base) - 1;
    int savedTop = G->trail_top;
    spines.pop_back();
    delete G;
    
    unwindTrail(savedTop);
    heap.setTop(new_base);
}

/**
 * yield_ "Main interpreter loop: starts from a spine and works
 * though a stream of answers, returned to the caller one
 * at a time, until the spines stack is empty - when it
 * returns null." [Engine.java]
 */
Spine* Engine::yield_() {
    while (!spines.empty()) {
        Spine* G = spines.back(); // was "peek()" in Java

        if (!hasClauses(G)) {
            popSpine();
            continue;
        }
        Spine *C = unfold(G);
        if (nullptr == C) {
            popSpine(); // no matches
            continue;
        }
        if (hasGoals(C)) {
            spines.push_back(C);
            continue;
        }
        return C; // answer
    }
    return nullptr;
}

Object Engine::exportTerm(cell x) {

    x = deref(x);
    int t = cell::tagOf(x);
    int w = cell::detag(x);

    Object res;
    switch (t) {
        case cell::C_: res = getSym(w);     break;
        case cell::N_: res = Integer(w);            break;
        case cell::V_: res = cstr("V") + w;         break;
            /*case U_:*/ 

        case cell::R_: {
                    cell a = cell_at(w);
                    if (!cell::isArgOffset(a)) {
                        throw logic_error(cstr("*** should be A, found=") + showCell(a));
                    }
                    int n = cell::detag(a);
                    vector<Object> args;
                    int k = w + 1;
                    for (int i = 0; i < n; i++) {
                        int j = k + i;
                        cell c = cell_at(j);
                        Object o = exportTerm(c);
                        args.push_back(o);
                    }
                    res = args;
                }
                break;
        default:
                    throw logic_error(cstr("*BAD TERM*") + showCell(x));
    }
    return res;
}

string Engine::showCell(cell w) {
    int t = cell::tagOf(w);
    int val = cell::detag(w);
    string s = "";
    string sym = "";

    switch (t) {
        case cell::V_:    s = cstr("v:") + val;        break;
        case cell::U_:    s = cstr("u:") + val;        break;
        case cell::N_:    s = cstr("n:") + val;        break;
        case cell::C_:    s = cstr("c:") + getSym(val);break;
        case cell::R_:    s = cstr("r:") + val;        break;
        case cell::A_:    s = cstr("a:") + val;        break;
        default:    s = cstr("*BAD*=") + w.as_int();
    }
    return s;
}

/**
 * "Pushes slice[from,to] at given base onto the heap."
 * b has cell structure, i.e, index, shifted left 3 bits, with tag V_
 */
void Engine::pushCells(cell b, int from, int upto, int base) {

    int count = upto - from;
    ensureSize(count);

    bool unroll = true; // Fails without RAW CellStack -- vector top-of-stack not updated
                         // No obvious way to do that, either, without push_back().
    if (unroll) {
        cell* srcp = heap.data() + base + from;
        cell* dstp = (cell*)(heap.data() + heap.getTop()) + 1;
        heap.setTop(heap.getTop() + count);
	cp_cells(b,srcp,dstp,count);
    }
    else {
        for (int i = from; i < upto; i++) {
            heap.push(cell::relocate(b, heap.get(base + i)));;
        }
    }
}

/**
 * "Pushes slice[from,to] at given base onto the heap."
 *  TODO: Identical to pushToTopOfHeap()?
 * 
 */
void Engine::pushCells(cell b, int from, int to, vector<cell> cells) {
    int count = to - from;
    ensureSize(count);

    bool unroll = true;
    if (unroll) {
        cell* heap_dst = (cell*)(heap.data() + heap.getTop()) + 1;
        heap.setTop(heap.getTop() + count);
	cp_cells(b,cells.data(),heap_dst,count);
    }
    else
	for (int i = from; i < to; i++)
	    heap.push(cell::relocate(b, cells[i]));
}

/**
 * "Copies and relocates body of clause at offset from heap to heap
 * while also placing head as the first element of array 'goals' that,
 * when returned, contains references to the toplevel spine of the clause."
 */
vector<cell> Engine::pushBody(cell b, cell head, Clause &C) {
    pushCells(b, C.neck, C.len, C.base);
    int l = C.goal_refs.size();
    vector<cell> goals(l);
    goals[0] = head;
    bool unroll = true;
    if (unroll)
	cp_cells (b, C.goal_refs.data()+1, goals.data()+1, l-1);
    else
        for (int k = 1; k < l; k++)
            goals[k] = cell::relocate(b, C.goal_refs[k]);
    return goals;
}

void Engine::makeIndexArgs(Spine *G, cell goal) {
    if (G->index_vector[0] != -1 || !hasGoals(G))
        return;
    int p = 1 + cell::detag(goal);
    int n = min(MAXIND, cell::detag(getRef(goal)));
    for (int i = 0; i < n; i++) {
        G->index_vector[i] = cell2index(deref(cell_at(p + i))).as_int();
    }
}

t_index_vector Engine::getIndexables(cell ref) {
    int p = 1 + cell::detag(ref);
    int n = cell::detag(getRef(ref));
    t_index_vector index_vector = { -1,-1,-1 };
    for (int i = 0; i < MAXIND && i < n; i++) {
        cell c = deref(cell_at(p + i));
        index_vector[i] = cell2index(c).as_int();
    }
    return index_vector;
}

cell Engine::cell2index(cell c) {
    cell x = 0;
    int t = cell::tagOf(c);
    switch (t) {
    case cell::R_:
        x = getRef(c);
        break;
    case cell::C_:
    case cell::N_:
        x = c;
        break;
    }
    return x;
}

/**
 * Copies and relocates the head of clause C from heap to heap.
 */
cell Engine::pushHeadtoHeap(cell b, const Clause& C) {
    pushCells(b, 0, C.neck, C.base);
    cell head = C.goal_refs[0];
    cell reloc_head = cell::relocate(b, head);
    return reloc_head;
}

void Engine::put(t_index_vector& keys, int val) {
    for (int i = 0; i < imaps.size(); i++) {
        int key = keys[i];
        if (key != 0) {
            IMap::put_(imaps, i, key, val);
        }
        else {
            var_maps[size_t(i)][val] = val;
        }
    }
}

vector<IMap> Engine::index(vector<Clause> clauses) {
    if (clauses.size() < START_INDEX)
        return vector<IMap>();  // something minimal, IFFY
    imaps = vector<IMap>(var_maps.size());
    for (size_t i = 0; i < clauses.size(); i++) {
        Clause c = clauses[i];
        put(c.index_vector, int(i + 1)); // $$$ UGLY INC
        // because possible_match() is using 0 as "ignore"
    }
    return imaps;
}

string Engine::showCells2(int base, int len) {
    string buf;
    for (int k = 0; k < len; k++) {
        cell instr = cell_at(base + k);
        buf += cstr("[") + base + k + "]" + showCell(instr) + " ";
    }
    return buf;
}
string Engine::showCells1(vector<cell> cs) {
    string buf;
    for (size_t k = 0; k < cs.size(); k++)
        buf += cstr("[") + k + "]" + showCell(cs[k]) + " ";
    return buf;
}

}
