<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.iprolog</a> &gt; <span class="el_source">IntMap.java</span></div><h1>IntMap.java</h1><pre class="source lang-java linenums">/**
 * derived from code at https://github.com/mikvor/hashmapTest
 */
package org.iprolog;
class IntMap implements java.io.Serializable {
  private static final long serialVersionUID = 1L;

  private static final int FREE_KEY = 0;

  static final int NO_VALUE = 0;

  /** Keys and values */
  private int[] m_data;

  /** Do we have 'free' key in the map? */
  private boolean m_hasFreeKey;
  /** Value of 'free' key */
  private int m_freeValue;

  /** Fill factor, must be between (0 and 1) */
  private final float m_fillFactor;
  /** We will resize a map once it reaches this size */
  private int m_threshold;
  /** Current map size */
  private int m_size;

  /** Mask to calculate the original position */
  private int m_mask;
  private int m_mask2;

  IntMap() {
<span class="nc" id="L32">    this(1 &lt;&lt; 2);</span>
<span class="nc" id="L33">  }</span>

  IntMap(final int size) {
<span class="nc" id="L36">    this(size, 0.75f);</span>
<span class="nc" id="L37">  }</span>

<span class="nc" id="L39">  IntMap(final int size, final float fillFactor) {</span>
<span class="nc bnc" id="L40" title="All 4 branches missed.">    if (fillFactor &lt;= 0 || fillFactor &gt;= 1)</span>
<span class="nc" id="L41">      throw new IllegalArgumentException(&quot;FillFactor must be in (0, 1)&quot;);</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">    if (size &lt;= 0)</span>
<span class="nc" id="L43">      throw new IllegalArgumentException(&quot;Size must be positive!&quot;);</span>
<span class="nc" id="L44">    final int capacity = arraySize(size, fillFactor);</span>
<span class="nc" id="L45">    m_mask = capacity - 1;</span>
<span class="nc" id="L46">    m_mask2 = capacity * 2 - 1;</span>
<span class="nc" id="L47">    m_fillFactor = fillFactor;</span>

<span class="nc" id="L49">    m_data = new int[capacity * 2];</span>
<span class="nc" id="L50">    m_threshold = (int) (capacity * fillFactor);</span>
<span class="nc" id="L51">  }</span>

  final int get(final int key) {
<span class="nc" id="L54">    int ptr = (phiMix(key) &amp; m_mask) &lt;&lt; 1;</span>

<span class="nc bnc" id="L56" title="All 2 branches missed.">    if (key == FREE_KEY)</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">      return m_hasFreeKey ? m_freeValue : NO_VALUE;</span>

<span class="nc" id="L59">    int k = m_data[ptr];</span>

<span class="nc bnc" id="L61" title="All 2 branches missed.">    if (k == FREE_KEY)</span>
<span class="nc" id="L62">      return NO_VALUE; //end of chain already</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">    if (k == key) //we check FREE prior to this call</span>
<span class="nc" id="L64">      return m_data[ptr + 1];</span>

    while (true) {
<span class="nc" id="L67">      ptr = ptr + 2 &amp; m_mask2; //that's next index</span>
<span class="nc" id="L68">      k = m_data[ptr];</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      if (k == FREE_KEY)</span>
<span class="nc" id="L70">        return NO_VALUE;</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      if (k == key)</span>
<span class="nc" id="L72">        return m_data[ptr + 1];</span>
    }
  }

  // for use as IntSet - Paul Tarau

  final boolean contains(final int key) {
<span class="nc bnc" id="L79" title="All 2 branches missed.">    return NO_VALUE != get(key);</span>
  }

  final boolean add(final int key) {
<span class="nc bnc" id="L83" title="All 2 branches missed.">    return NO_VALUE != put(key, 666);</span>
  }

  boolean delete(final int key) {
<span class="nc bnc" id="L87" title="All 2 branches missed.">    return NO_VALUE != remove(key);</span>
  }

  final boolean isEmpty() {
<span class="nc bnc" id="L91" title="All 2 branches missed.">    return 0 == m_size;</span>
  }

  final static void intersect0(final IntMap m, final IntMap[] maps, final IntMap[] vmaps, final IntStack r) {
<span class="nc" id="L95">    final int[] data = m.m_data;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    for (int k = 0; k &lt; data.length; k += 2) {</span>
<span class="nc" id="L97">      boolean found = true;</span>
<span class="nc" id="L98">      final int key = data[k];</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      if (FREE_KEY == key) {</span>
<span class="nc" id="L100">        continue;</span>
      }
<span class="nc bnc" id="L102" title="All 2 branches missed.">      for (int i = 1; i &lt; maps.length; i++) {</span>
<span class="nc" id="L103">        final IntMap map = maps[i];</span>
<span class="nc" id="L104">        final int val = map.get(key);</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (NO_VALUE == val) {</span>
<span class="nc" id="L107">          final IntMap vmap = vmaps[i];</span>
<span class="nc" id="L108">          final int vval = vmap.get(key);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">          if (NO_VALUE == vval) {</span>
<span class="nc" id="L110">            found = false;</span>
<span class="nc" id="L111">            break;</span>
          }
        }
      }
<span class="nc bnc" id="L115" title="All 2 branches missed.">      if (found) {</span>
<span class="nc" id="L116">        r.push(key);</span>
      }
    }
<span class="nc" id="L119">  }</span>

  final static IntStack intersect(final IntMap[] maps, final IntMap[] vmaps) {
<span class="nc" id="L122">    final IntStack r = new IntStack();</span>

<span class="nc" id="L124">    intersect0(maps[0], maps, vmaps, r);</span>
<span class="nc" id="L125">    intersect0(vmaps[0], maps, vmaps, r);</span>
<span class="nc" id="L126">    return r;</span>
  }

  // end changes

  final int put(final int key, final int value) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">    if (key == FREE_KEY) {</span>
<span class="nc" id="L133">      final int ret = m_freeValue;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      if (!m_hasFreeKey) {</span>
<span class="nc" id="L135">        ++m_size;</span>
      }
<span class="nc" id="L137">      m_hasFreeKey = true;</span>
<span class="nc" id="L138">      m_freeValue = value;</span>
<span class="nc" id="L139">      return ret;</span>
    }

<span class="nc" id="L142">    int ptr = (phiMix(key) &amp; m_mask) &lt;&lt; 1;</span>
<span class="nc" id="L143">    int k = m_data[ptr];</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (k == FREE_KEY) //end of chain already</span>
    {
<span class="nc" id="L146">      m_data[ptr] = key;</span>
<span class="nc" id="L147">      m_data[ptr + 1] = value;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">      if (m_size &gt;= m_threshold) {</span>
<span class="nc" id="L149">        rehash(m_data.length * 2); //size is set inside</span>
      } else {
<span class="nc" id="L151">        ++m_size;</span>
      }
<span class="nc" id="L153">      return NO_VALUE;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    } else if (k == key) //we check FREE prior to this call</span>
    {
<span class="nc" id="L156">      final int ret = m_data[ptr + 1];</span>
<span class="nc" id="L157">      m_data[ptr + 1] = value;</span>
<span class="nc" id="L158">      return ret;</span>
    }

    while (true) {
<span class="nc" id="L162">      ptr = ptr + 2 &amp; m_mask2; //that's next index calculation</span>
<span class="nc" id="L163">      k = m_data[ptr];</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (k == FREE_KEY) {</span>
<span class="nc" id="L165">        m_data[ptr] = key;</span>
<span class="nc" id="L166">        m_data[ptr + 1] = value;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (m_size &gt;= m_threshold) {</span>
<span class="nc" id="L168">          rehash(m_data.length * 2); //size is set inside</span>
        } else {
<span class="nc" id="L170">          ++m_size;</span>
        }
<span class="nc" id="L172">        return NO_VALUE;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      } else if (k == key) {</span>
<span class="nc" id="L174">        final int ret = m_data[ptr + 1];</span>
<span class="nc" id="L175">        m_data[ptr + 1] = value;</span>
<span class="nc" id="L176">        return ret;</span>
      }
    }
  }

  final int remove(final int key) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">    if (key == FREE_KEY) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (!m_hasFreeKey)</span>
<span class="nc" id="L184">        return NO_VALUE;</span>
<span class="nc" id="L185">      m_hasFreeKey = false;</span>
<span class="nc" id="L186">      --m_size;</span>
<span class="nc" id="L187">      return m_freeValue; //value is not cleaned</span>
    }

<span class="nc" id="L190">    int ptr = (phiMix(key) &amp; m_mask) &lt;&lt; 1;</span>
<span class="nc" id="L191">    int k = m_data[ptr];</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (k == key) //we check FREE prior to this call</span>
    {
<span class="nc" id="L194">      final int res = m_data[ptr + 1];</span>
<span class="nc" id="L195">      shiftKeys(ptr);</span>
<span class="nc" id="L196">      --m_size;</span>
<span class="nc" id="L197">      return res;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">    } else if (k == FREE_KEY)</span>
<span class="nc" id="L199">      return NO_VALUE; //end of chain already</span>
    while (true) {
<span class="nc" id="L201">      ptr = ptr + 2 &amp; m_mask2; //that's next index calculation</span>
<span class="nc" id="L202">      k = m_data[ptr];</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">      if (k == key) {</span>
<span class="nc" id="L204">        final int res = m_data[ptr + 1];</span>
<span class="nc" id="L205">        shiftKeys(ptr);</span>
<span class="nc" id="L206">        --m_size;</span>
<span class="nc" id="L207">        return res;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      } else if (k == FREE_KEY)</span>
<span class="nc" id="L209">        return NO_VALUE;</span>
    }
  }

  final private int shiftKeys(int pos) {
    // Shift entries with the same hash.
    int last, slot;
    int k;
<span class="nc" id="L217">    final int[] data = m_data;</span>
    while (true) {
<span class="nc" id="L219">      pos = (last = pos) + 2 &amp; m_mask2;</span>
      while (true) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if ((k = data[pos]) == FREE_KEY) {</span>
<span class="nc" id="L222">          data[last] = FREE_KEY;</span>
<span class="nc" id="L223">          return last;</span>
        }
<span class="nc" id="L225">        slot = (phiMix(k) &amp; m_mask) &lt;&lt; 1; //calculate the starting slot for the current key</span>
<span class="nc bnc" id="L226" title="All 10 branches missed.">        if (last &lt;= pos ? last &gt;= slot || slot &gt; pos : last &gt;= slot &amp;&amp; slot &gt; pos) {</span>
<span class="nc" id="L227">          break;</span>
        }
<span class="nc" id="L229">        pos = pos + 2 &amp; m_mask2; //go to the next entry</span>
      }
<span class="nc" id="L231">      data[last] = k;</span>
<span class="nc" id="L232">      data[last + 1] = data[pos + 1];</span>
    }
  }

  final int size() {
<span class="nc" id="L237">    return m_size;</span>
  }

  final private void rehash(final int newCapacity) {
<span class="nc" id="L241">    m_threshold = (int) (newCapacity / 2 * m_fillFactor);</span>
<span class="nc" id="L242">    m_mask = newCapacity / 2 - 1;</span>
<span class="nc" id="L243">    m_mask2 = newCapacity - 1;</span>

<span class="nc" id="L245">    final int oldCapacity = m_data.length;</span>
<span class="nc" id="L246">    final int[] oldData = m_data;</span>

<span class="nc" id="L248">    m_data = new int[newCapacity];</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">    m_size = m_hasFreeKey ? 1 : 0;</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">    for (int i = 0; i &lt; oldCapacity; i += 2) {</span>
<span class="nc" id="L252">      final int oldKey = oldData[i];</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">      if (oldKey != FREE_KEY) {</span>
<span class="nc" id="L254">        put(oldKey, oldData[i + 1]);</span>
      }
    }
<span class="nc" id="L257">  }</span>

  /** Taken from FastUtil implementation */

  /** Return the least power of two greater than or equal to the specified value.
   *
   * &lt;p&gt;Note that this function will return 1 when the argument is 0.
   *
   * @param x a long integer smaller than or equal to 2&lt;sup&gt;62&lt;/sup&gt;.
   * @return the least power of two greater than or equal to the specified value.
   */
  final private static long nextPowerOfTwo(long x) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">    if (x == 0)</span>
<span class="nc" id="L270">      return 1;</span>
<span class="nc" id="L271">    x--;</span>
<span class="nc" id="L272">    x |= x &gt;&gt; 1;</span>
<span class="nc" id="L273">    x |= x &gt;&gt; 2;</span>
<span class="nc" id="L274">    x |= x &gt;&gt; 4;</span>
<span class="nc" id="L275">    x |= x &gt;&gt; 8;</span>
<span class="nc" id="L276">    x |= x &gt;&gt; 16;</span>
<span class="nc" id="L277">    return (x | x &gt;&gt; 32) + 1;</span>
  }

  /** Returns the least power of two smaller than or equal to 2&lt;sup&gt;30&lt;/sup&gt;
   * and larger than or equal to &lt;code&gt;Math.ceil( expected / f )&lt;/code&gt;.
   *
   * @param expected the expected number of elements in a hash table.
   * @param f the load factor.
   * @return the minimum possible size for a backing array.
   * @throws IllegalArgumentException if the necessary size is larger than 2&lt;sup&gt;30&lt;/sup&gt;.
   */
  final private static int arraySize(final int expected, final float f) {
<span class="nc" id="L289">    final long s = Math.max(2, nextPowerOfTwo((long) Math.ceil(expected / f)));</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (s &gt; 1 &lt;&lt; 30)</span>
<span class="nc" id="L291">      throw new IllegalArgumentException(&quot;Too large (&quot; + expected + &quot; expected elements with load factor &quot; + f + &quot;)&quot;);</span>
<span class="nc" id="L292">    return (int) s;</span>
  }

  //taken from FastUtil
  private static final int INT_PHI = 0x9E3779B9;

  final private static int phiMix(final int x) {
<span class="nc" id="L299">    final int h = x * INT_PHI;</span>
<span class="nc" id="L300">    return h ^ h &gt;&gt; 16;</span>
  }

  @Override
  public String toString() {
    //return java.util.Arrays.toString(m_data);
<span class="nc" id="L306">    final StringBuffer b = new StringBuffer(&quot;{&quot;);</span>
<span class="nc" id="L307">    final int l = m_data.length;</span>
<span class="nc" id="L308">    boolean first = true;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">    for (int i = 0; i &lt; l; i += 2) {</span>

<span class="nc" id="L311">      final int v = m_data[i];</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">      if (v != FREE_KEY) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (!first) {</span>
<span class="nc" id="L314">          b.append(',');</span>
        }
<span class="nc" id="L316">        first = false;</span>
<span class="nc" id="L317">        b.append(v - 1);</span>
      }
    }
<span class="nc" id="L320">    b.append(&quot;}&quot;);</span>
<span class="nc" id="L321">    return b.toString();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>