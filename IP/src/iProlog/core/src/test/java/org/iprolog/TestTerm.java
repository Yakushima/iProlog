package org.iprolog;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertFalse;


import java.util.LinkedList;
import java.util.Arrays;

public class TestTerm {

    private static Term v_(String s) { return Term.variable(s); }
    private static Term c_(String s) { return Term.constant(s); }
    private static Term s_(String s) { return Term.compound(s); }
    private static Term s_(String s, Term... ts) {
                                        Term xt = Term.compound(s); 
                                        for (Term t : ts)
                                            xt.takes_this(t);
                                        return xt;
                                    }
    private static Term s_(String s, LinkedList<Term> llt) { return Term.compound(s,llt); }
    private static Term e_(Term lhs, Term rhs) { return Term.equation (lhs,rhs); }
    private static Term l_(Term... ts) {
        LinkedList<Term> llt = new LinkedList<Term>();
        for (Term t : ts)
            llt.add(t);
        Term x = Term.termlist (llt);
        assert x != null;
        return x;
    }

    /**
   * Initiator and consumer of the stream of answers
   * generated by this engine.
   */
    private void expect_from(Prog P, String[] whats_expected) {
        Object POJO_Ans;

        if (whats_expected != null) {
            Main.println ("whats_expected =");
            for (String s : whats_expected) {
                Main.println ("  Looks like " + s + " when prolog_mode =  " + Term.in_Prolog_mode);
            }
        }

        // Going through the Java Object interface, unfortunately.

        while ((POJO_Ans = P.POJO_ask()) != null) {
            Main.println ("\nIn POJO_ask() loop....");
            assert POJO_Ans instanceof Object[];  // because it'll be "[goal, <answer>]"

            Object[] POJO_goal_answers = (Object[]) POJO_Ans;

            LinkedList<Term> llt = Prog.make_terms_from(POJO_goal_answers);

            assert (llt.size() == 1);
            Term goal_ans = llt.get(0);
            assert goal_ans.is_a_compound();
            assert goal_ans.c.compareTo("goal") == 0;
            LinkedList<Term> args = goal_ans.args();

            int i = 0;
            String to_compare = "";
            for (Term t : args) {
                to_compare += t.toString();
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  goal ["+(i++)+"] = " + t);
            }
 
            String sg = P.showTerm(POJO_goal_answers[0]);
            assert sg.equals("goal");   // because it'll be "[goal, <answer>]"
            assert POJO_goal_answers.length > 1;
            String show_POJO_object = P.showTerm(POJO_goal_answers[1]);

            if (whats_expected != null) {
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  show_POJO_object = " + show_POJO_object);
                // assert Arrays.asList(whats_expected).contains(so);
            } else {
                Main.println (" yielding: " + show_POJO_object);
            }
        }
        Main.println ("... expect_from exiting.");
    }

    private void try_t() {
        Main.println ("\n==== try_t ====");
        /*
         * live_(i_).
         * live_(you_).
         * good_(Person) :- live_(Person).
         * goal(Person):-good_(Person).
         * 
                * live_ i_ .
                * live_ you_ .
                * good_ Person
                * if
                *   live_ Person .
                *
                * goal Person
                * if
                *   good_ Person .

         */

        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println ("\n try_t: Construct data structures for try_t() case and ...");

        String expected[] = {"I"
                            ,"you"
                            };

        Term vPerson = v_("person");

        LinkedList<Clause> llc = new LinkedList<Clause>();

        for (String s : expected) {
             Clause cl = Clause.f__("live_", l_(c_(s)));
             llc.add (cl);
             Main.println ("try_t: Adding clause: ");
             Main.println ("try_t: " + cl.toString());
             Main.println ("");
            // llc.add (Clause.f__("live_", c_(s)));
        }

        // llc.add (Clause.f__("good_", vPerson).if__(s_("live_", vPerson)));
        // llc.add (Clause.f__("goal",  vPerson).if__(s_("good_", vPerson)));
        llc.add (Clause.f__("goal",  vPerson).if__(s_("live_", vPerson)));

        Main.println ("===== try_t: cl.toString() loop ===============");
        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Main.println ("===== try_t: flatten transform =======");
        for (Clause cl : llc) {
            // Main.println ("cl before flatten = " + cl);
            Term.fatten(cl);  // in-place transform
            // Main.println ("cl after flatten = " + cl);
        }
        
        Main.println ("===== try_t: FLATTENED cl.toString() loop ===============");
        x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Main.println ("===== try_t: Calling new Prog: ===============");
        Prog P = new Prog(x_out, false);

        Term.set_Prolog();
        /* 
        Main.println ("\n=== try_t: Pretty-print Prolog from it ===");
        P.ppCode();
        */

        expect_from(P, expected);
    }

    private void try_t_J() {
        Main.println ("\n==== try_t_J ====");
        
        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println ("\n try_t_J: Construct data structures for try_t_J() case and ...");

        String expected[] = {"私", "あなた"};
        Term vPerson = v_("人");
        LinkedList<Clause> llc = new LinkedList<Clause>();
        for (String s : expected)
            llc.add (Clause.f__("いきる", c_(s)));
        llc.add (Clause.f__("いいです", vPerson).if__(s_("いきる", vPerson)));
        llc.add (Clause.f__("goal",  vPerson).if__(s_("いいです", vPerson)));
        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Prog P = new Prog(x_out, false);

        Term.set_Prolog();
        /*
        Main.println ("\n=== try_t_J: Pretty-print Prolog from it ===");
        P.ppCode();
        */

        // expect_from(P, expected);
        expect_from(P,null);
    }

    private void list_test() {
        Main.println ("list_test entered...");

        Term.reset_gensym();
        Term.set_TarauLog();

        Term c0 = c_("0");
        Term c1 = c_("1");
        Term c2 = c_("2");
        Term l = l_(c0,c1,c2);
        assert l != null;
        assert l.is_a_termlist();

        Main.println ("l = " + l);

        Main.println ("\n list_test: Construct data structures for try_t() case and ...");

        String expected[] = {"list(0,1,2)", "[1|0]"};

        LinkedList<Clause> llc = new LinkedList<Clause>();

        Term V = v_("V");

        llc.add (Clause.f__("zero_and_one", V).if__(e_(V,l)));
        // llc.add (Clause.f__("zero_and_one", l));

        llc.add (Clause.f__("zero_and_one", V).if__(e_(V,l_(c1,c0))));
        // llc.add (Clause.f__("zero_and_one", l_(c1,c0)));

        llc.add (Clause.f__("goal",  V).if__(s_("zero_and_one", V)));

        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Prog P = new Prog(x_out, false);

        Term.set_Prolog();
        /*
        Main.println ("\n=== list_test: Pretty-print Prolog from it ===");
        P.ppCode();
        */

        expect_from(P, expected);

        Main.println ("list_test exited...");       
    }

    private void try_add() {
        Main.println ("\n==== try_add() ====");
        /*
        the_sum_of(0,X,X).
        the_sum_of(the_successor_of(X),Y,the_successor_of(Z)):-the_sum_of(X,Y,Z).
        goal(R):-
         the_sum_of(the_successor_of(the_successor_of(0)),the_successor_of(the_successor_of(0)),R).

            the_sum_of 0 X X .

            the_sum_of _0 Y _1 and
              _0 holds the_successor_of X and
              _1 holds the_successor_of Z
            if
            the_sum_of X Y Z .

            goal R
            if
              the_sum_of _0 _1 R and
              _0 holds the_successor_of _2 and
              _2 holds the_successor_of 0 and
              _1 holds the_successor_of _3 and
              _3 holds the_successor_of 0 .
         */

        // out = "";
        Term.reset_gensym();

        LinkedList<Clause> llc = new LinkedList<Clause>();
        Term vX = v_("X");
        Term vY = v_("Y");
        Term vZ = v_("Z");
        Term c0 = c_("0");
        Term succ_X = s_("the_successor_of", vX);
        Term succ_Z = s_("the_successor_of", vZ);
        Term succ_0 = s_("the_successor_of", c0);
        Term vR = v_("R");

        llc.add(Clause.f__("the_sum_of", c0, vX, vX));
   

        Main.println ("\n=== try_add: Try adding 2+2 in unary, generating TarauLog ===");

        Term.set_TarauLog();

        Clause adder = Clause.f__("the_sum_of", succ_X,vY,succ_Z).if__(s_("the_sum_of",vX,vY,vZ));

        Main.println ("\n  try_add: adder before calling Term.fatten(adder) = \n" + adder + "\n");

        Term.fatten(adder);

        Main.println ("\n  try_add: adder AFTER calling Term.fatten(x) = \n" + adder + "\n");

        llc.add(adder);
/*
        // llc.add(Clause.f__("the_sum_of", succ_X,vY,succ_Z).if__(s_("the_sum_of",vX,vY,vZ)));

        // bodyless head to start
        Clause adder = Clause.f__("the_sum_of", succ_X, vY, succ_Z);
        assert adder.head.size() == 1;
        Main.println ("adder as just head so far = " + adder);
        // flatten it
        Term h = adder.head.peekFirst();
        Main.println ("adder head term extracted = " + h);
        LinkedList<Term> residue = h.fatten();
        assert adder.head != null;
        assert adder.head.size() > 0;
        assert residue != null;
        Main.println ("residue = " + residue);
 
        Main.println ("adder after flattening head = " + adder);
        // add the body
        adder = adder.if__(s_("the_sum_of", vX, vY, vZ));
        Main.println ("adder = " + adder);
        llc.add (adder);
*/
            // goal(R):-
            //  the_sum_of(the_successor_of(the_successor_of(0)),the_successor_of(the_successor_of(0)),R).
        
        Term.reset_gensym();
        Term two = s_("the_successor_of", succ_0);
        Clause g = Clause.f__("goal", vR).if__(s_("the_sum_of", two, two, vR));
        Term.fatten(g);
        Main.println ("  try_add: g AFTER flattening = " + g);
        llc.add(g);

        Main.println ("\n----- try_add: Clause construction through API: show x_out: --------");
        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Main.println ("----- try_add: Calling new Prog on x_out: --------");
        Prog P = new Prog(x_out, false);

        Term.set_Prolog();
        /*
        Main.println ("\n=== Pretty-print as Prolog ===");
        P.ppCode();
        */
        
        Main.println ("\n===<<< try_add: Starting to run >>>===");

        String[] these_answers = {
            "the_successor_of(the_successor_of(the_successor_of(the_successor_of(0))))"
        };

        expect_from(P, these_answers);
    }

    @Test
    public void mainTest() {
        Main.println ("************* Start Term test ********************");

        String gs = Term.gensym();
        assert gs.compareTo("_0") == 0;
        String gs1 = Term.gensym();
        assert gs1.compareTo("_1") == 0;
        Term.reset_gensym();

        String var_X = "X";
        Term vX = v_(var_X);
        assert vX.is_a_variable();

        String const_ooh = "ooh";
        Term cOoh = c_(const_ooh);
        assert cOoh.is_a_constant();

        String cmpnd_fnctr = "compound";
        Term C = s_(cmpnd_fnctr, vX,cOoh);
        assert C != null;
        assert C.is_a_compound();

        Term L = l_(vX,cOoh);
        assert L.is_a_termlist();

        // Main.println ("C=" + C);
        // iffy - depends on settings & formatting:
        String CC = cmpnd_fnctr + "(" + var_X + "," + const_ooh + ")";
        assert C.toString().compareTo(CC) == 0;
        // Main.println ("C.toString() = " + C.toString());

        // Main.println ("vX = " + vX);
        LinkedList<Term> fv1  = vX.fatten();
        assert fv1 != null;
        // Main.println ("vX flattened is " + vX);
        // Main.println ("fv1.size() = " + fv1.size());
        assert fv1.size() == 0;     // no residue because a var can't be flattened

        // Main.println ("cOoh = " + cOoh);
        LinkedList<Term> fc = cOoh.fatten();
        // Main.println ("fc.size() = " + fc.size());
        // Main.println ("cOoh is now " + cOoh);
        assert fc.size() == 0;

    Term.reset_gensym();
        // Main.println ("\nBefore flattening: C = " + C);
        LinkedList<Term> fCx  = C.fatten();
        assert fCx != null;
        // Main.println ("fCx.size() = " + fCx.size());
        // Main.println ("C is now " + C);
        // Main.println ("residue of flattening C, fCx = " + fCx);
        assert fCx.size() == 1;
        assert C.is_a_variable();
        assert fCx.peekFirst().is_an_equation();

    Term.reset_gensym();
        String cmpnd_fnctr1 = "compendium";
        Term C1arg1 = s_("foo", Term.constant("a"));
        Term C1arg2 = s_("bar", Term.variable("G"));
        Term C1 = s_ (cmpnd_fnctr1, C1arg1, C1arg2);
        assert C1.is_a_compound();

        // Main.println ("\nC1 pre-flattening is " + C1);
        LinkedList<Term> rC1 = C1.fatten();
        // Main.println ("C1 flattened is " + C1);
        // Main.println ("rC1.size() = " + rC1.size());
        // for (Term t : rC1) Main.println (" -- a flattened term t=" + t + ", t.is_flat()=" + t.is_flat());

        Term eqn1 = e_ (vX,cOoh);
        assert eqn1 != null;

        // Main.println ("eqn1 = " + eqn1);

        Term vY = v_("Y");
        assert vY.is_a_variable();
        Term C2 = s_("foo",C1);
        // Main.println ("\n\n\nC2 is " + C2 + ", C2.is_flat() = " + C2.is_flat());

        Term eqn2 = e_ (vY, C2);
        // Main.println ("eqn2 is " + eqn2 + ", eqn2.is_flat() = " + eqn2.is_flat());

        LinkedList<Term> flatcat = eqn2.fatten();
        // Main.println ("eqn2 is now " + eqn2.toString());
        // Main.println ("eqn2 Flattened flatcat: ");
        // for (Term t : flatcat) Main.println ("  -- " + t);

        // Main.println ("-----------------------------------------");

        String sum = "the_sum_of";
        String s = "the_successor_of";
        Term an_X = v_("X");
        Term a_Y  = v_("Y");
        Term s_of_X = s_ (s, an_X);
        Term s_of_Y = s_ (s, a_Y);
        Term summer_head = s_(sum,s_of_X, an_X, s_of_Y);

        // Main.println ("summer_head before flattening is "+ summer_head);

        LinkedList<Term> flattery = summer_head.fatten();
        // Main.println ("summer_head AFTER flattening is "+ summer_head);
        // for (Term t : flattery) Main.println (" -- flattery has " + t);


        // Add basic tests for making lists

        // nil / []
        //      TBD

        Term.reset_gensym();
        // singleton:
            Term singleton = l_(Term.constant("foo"));
            // Main.println ("\n-------\nsingleton = " + singleton);
            LinkedList<Term> fs = singleton.fatten();
            // Main.println ("fs.size() = " + fs.size());
            // Main.println ("fs is " + fs.toString());
            // Main.println ("post-flattening singleton is " + singleton);

        Term.reset_gensym();

            Term singleton_sublist = l_(Term.constant("foo"));

            Term nested = l_(Term.constant("bar"), singleton_sublist, Term.constant("quux"));
            // Main.println ("\n-------\ncomplex list pre-flattening is " + nested.toString());

            LinkedList<Term> ns = nested.fatten();
            // Main.println ("Nested list is now " + nested.toString() + " ns.size() = " + ns.size());

        Term.reset_gensym();     

        try_t();
        
        try_add();
        
        try_t_J();
        
        list_test();
        

        Main.println ("\n======== End Term test ====================");
    }
}
