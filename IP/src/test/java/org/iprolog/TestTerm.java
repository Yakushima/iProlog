package org.iprolog;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertFalse;


import java.util.LinkedList;
import java.time.Year;
import java.util.Arrays;
import java.util.function.Supplier;

public class TestTerm {

    private static final Term v_(String s) { return Term.variable(s); }
    private static final Term c_(String s) { return Term.constant(s); }
    private static final Term s_(String s) { return Term.compound(s); }
    private static final Term s_(String s, Term... ts) {
                                        Term xt = Term.compound(s); 
                                        for (Term t : ts)
                                            xt = xt.takes_this(t);
                                        return xt;
                                    }
    private static final Term e_(Term lhs, Term rhs) { return Term.equation (lhs,rhs); }
    private static final Term l_(Term... ts) {
                                        if (ts.length == 0)
                                            return c_("nil");
                                        return Term.termlist(ts);
                                    }
    private static final Term p_(Term car, Term cdr) {
                                        return Term.termpair(car,cdr);
                                    }

    // Tarau's code generates _<#> IDs from these, generally just
    // past the gensym count after flattening. Not clear where
    // this should go, if not in flatten().
    private Term _()            {
        return v_("_");
    }

    private Clause yes_ (Term hd) { return Clause.f__(hd); }

    private Term c0() { return c_("0"); }
    private Term c1() { return c_("1"); }
    private Term c2() { return c_("2"); }
    private Term c3() { return c_("3"); }

    private Term V()  { return v_("V"); }
    private Term X()  { return v_("X"); };
    private Term Y()  { return v_("Y"); };
    private Term Z()  { return v_("Z"); };

    private Term goal(Term x)  { return s_("goal",x); }

    LinkedList<Clause> said;

    private void start_new_test() {
        if (said == null)
            said = new LinkedList<Clause>();
        else
            said.clear();
    }

    private Clause say_(Clause cl) {
        assert said != null;
        said.add (cl);
        return cl;
    }
    private Clause say_(Term hd)   {
        assert said != null;
        Clause cl = yes_(hd);
        said.add (cl);
        return cl;
    }

    /**
   * Initiator and consumer of the stream of answers
   * generated by this engine.
   */
    private void expect_from(Prog P, String[] whats_expected) {
        Object POJO_Ans;

        Term.set_Prolog();

        if (whats_expected != null) {
            Main.println ("whats_expected =");
            for (String s : whats_expected) {
                Main.println ("  Looks like " + s + " when prolog_mode =  " + Term.in_Prolog_mode);
            }
        }

        // Going through the Java Object interface, unfortunately.

        Boolean yielded_something = false;
        while ((POJO_Ans = P.POJO_ask()) != null) {
            yielded_something = true;
            Main.println ("\nIn POJO_ask() loop....");
            assert POJO_Ans instanceof Object[];  // because it'll be "[goal, <answer>]"

            Object[] POJO_goal_answers = (Object[]) POJO_Ans;

            LinkedList<Term> llt = Prog.make_terms_from(POJO_goal_answers);

            assert (llt.size() == 1);
            Term goal_ans = llt.get(0);
            assert goal_ans.is_a_compound();
            assert goal_ans.c().compareTo("goal") == 0;
            Term args = goal_ans.args();

            int i = 0;
            String to_compare = "";
            for (Term t = args; t != null; t = t.next) {
                to_compare += t.toString();
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  goal ["+(i++)+"] = " + t);
            }
 
            String sg = P.showTerm(POJO_goal_answers[0]);
            assert sg.equals("goal");   // because it'll be "[goal, <answer>]"
            assert POJO_goal_answers.length > 1;
            assert POJO_goal_answers.length < 3;
            // Main.println ("POJO_goal_answers[1] is " + POJO_goal_answers[1]);
            String show_POJO_object = P.showTerm(POJO_goal_answers[1]);

            if (whats_expected != null) {
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  show_POJO_object = " + show_POJO_object);
                assert Arrays.asList(whats_expected).contains(show_POJO_object);
            } else {
                Main.println (" yielding: " + show_POJO_object);
            }
        }
        assert whats_expected == null || yielded_something;

        Main.println ("... expect_from exiting.");
    }



    private void try_it(LinkedList<Clause> said, String[] whats_expected) {

        assert !said.isEmpty();
        Main.println (" ===== try_it() entering....");
        String s = "[";

        if (whats_expected == null)
            s += "<null>";
        else {  String sep = "";
                for (int i = 0; i < whats_expected.length; ++i) {
                    s += sep;
                    sep = ",";
                    s += whats_expected[i];
                }
        }
        s += "]";
        Main.println ("     whats_expected = " + s);

        String asm_txt;
        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println ("   ===== try_it(): flatten transform =======");
        asm_txt = "";
        for (Clause cl : said) {
            cl.flatten();
            asm_txt += cl.toString()+System.lineSeparator();
        }

        Main.println ("   ===== try_it(): Calling new Prog: ===============");
        Prog P = new Prog(asm_txt, false);

        expect_from(P, whats_expected); 

        Main.println ("  ===== exiting try_it()");
    }

    private class TryT {
        private  Term good_(Term x)    { return s_("good_", x); }
        private  Term live_(Term x)    { return s_("live_", x); }
        private  Term Person()         { return v_("Person");   }

        private void test() {
            Main.println("\n==== TryT.test() entered ... ====");

            start_new_test();

            String expected[] = {"I", "you", "them", "us"};

            for (String s : expected)
                say_(live_(c_(s)));

            say_(good_(Person())).if_(live_(Person()));
            say_(goal(Person())).if_(good_(Person()));

            try_it(said, expected);
        }
    }

private class TrySimple {
    private Term   Foo()            { return  v_("Foo");                 }
    private Term   dookie(Term x)   { return  s_("dookie", x);           }

    private void test() {
        Main.println(" ======== TrySimple.test() entering....");

        start_new_test();

        say_(dookie(l_()));
        say_(dookie(c0()));
        say_(goal(Foo())).if_(dookie(Foo()));

        String expected[] = {"nil", "0"};
        try_it(said, expected);

        Main.println (" ======= TrySimple.test() exiting ....");
    }
};

    private class TryBig {
        Term Ys() { return v_("Ys"); }
        Term Xs() { return v_("Xs"); }
        Term Zs() { return v_("Zs"); }
        Term append(Term this_, Term that, Term result) {
            return s_("append", this_, that, result);
        }
        Term nrev(Term x, Term y) { return s_("nref", x, y); }
        Term dup(Term a, Term b, Term c) { return s_("dup", a, b, c); }
        Term next_number_after(Term a, Term a_plus_1) {
            return s_("next_number_after", a, a_plus_1);
        }

        private void test() {  // based on Tarau's original progs/big.pl
            Main.println("\n===== TryBig.test() entering ....");

            start_new_test();

            say_(append(l_(), Ys(), Ys()));
            say_(append(p_(X(), Xs()), Ys(), p_(X(), Zs()))).
                    if_(append(Xs(), Ys(), Zs()));
            say_(nrev(l_(), l_()));
            say_(nrev(p_(X(),Xs()), Zs())).
                    if_(    nrev(Xs(), Ys()),
                            append(Ys(), l_(X()), Zs()));

            for (Integer i = 0; i < 18; ++i) {
                Integer i_next = i + 1;
                say_(next_number_after(c_(i.toString()), c_(i_next.toString())));
            }
            say_(dup(c0(), X(), X()));

            Term R = v_("R");
            Term XX = v_("XX");
            Term N = v_("N");
            Term N1 = v_("N1");
            // dup(N,X,R):-next_number_after(N1,N),append(X,X,XX),dup(N1,XX,R).
            said.add(Clause.f__(dup(N, X(), R)).
                    if_(    next_number_after(N1, N),
                            append(X(), X(), XX),
                            dup(N1, XX, R)));

            // goal([X,Y]):-dup(18,[a,b,c,d],[X,Y|_]).
            Term l_a_b_c_d = l_(c_("a"), c_("b"), c_("c"), c_("d"));

            Term p = p_(Y(), _());
            say_(goal(l_(X(), Y())))
                    .if_(dup(c_("18"), l_a_b_c_d, l_(X(), p)));

            String expected[] = {"[a,b]"};
            try_it(said, expected);

            Main.println(" ======== ryBig.test() exiting . . .");
        }
    }

    private class TryBar {
        private Term F()  { return v_("F"); }
        private Term eq(Term x, Term y) { return s_("eq", x, y); }
        private Term foo(Term x)        { return s_("foo", x);   }

        private void test() {

            Main.println("\n==== TryBar.test() (list composition with | symbol) entered ... ====");

            start_new_test();

            say_(eq( X(), X()));
            say_(foo(p_(X(), Y()))).
                    if_(    eq( X(), c1()),
                            eq( Y(), c_("nil")));
            say_(foo(p_(X(), Y()))).
                    if_(    eq( X(), c2()),
                            eq( Y(), c3()));
            say_(foo(l_(X(), Y()))).
                    if_(    eq( X(), c2()),
                            eq( Y(), c3()));
            say_(goal(F())).
                    if_(    foo(F()));

            String expected[] = {"[1]", "[2|3]", "[2,3]"};
            try_it(said, expected);

            Main.println("\n==== TryBar.test() exiting .... ====");
        }
    }

    class TryPerms {
        private Term eq(Term x, Term y) { return s_("eq", x, y); }
        private Term Xs() { return v_("Xs"); }
        private Term Ys() { return v_("Ys"); }
        private Term Zs() { return v_("Zs"); }

        private Term sel(Term a, Term b, Term c) { return s_("sel", a, b, c); }
        private Term perm(Term x, Term y)        { return s_("perm", x, y);   }
        private Term app(Term a, Term b, Term c) { return s_("app", a, b, c); }
        private Term nrev(Term x, Term y)        { return s_("nrev", x, y);   }
        private Term input(Term x)               { return s_("input", x);     }

        private void test() {
            Main.println("\n==== TryPerms.test() entered ....  ====");

            start_new_test();

            say_( eq(X(), X()) );
            say_( sel(X(), p_(X(), Xs()), Xs()) );
            say_( sel(X(), p_(Y(), Xs()), p_(Y(), Ys()))).
                    if_(    sel(X(), Xs(), Ys()) );
            say_( perm(l_(), l_()) );
            say_( perm(p_(X(), Xs()), Zs())).
                    if_(    perm(Xs(), Ys()),
                            sel(X(), Zs(), Ys()) );
            say_( app(l_(), Xs(), Xs()) );
            say_( app(p_(X(), Xs()), Ys(), p_(X(), Zs()))).
                    if_(app(Xs(), Ys(), Zs()) );
            say_( nrev(l_(), l_()));
            say_( nrev(p_(X(), Xs()), Zs())).
                    if_(    nrev(Xs(), Ys()),
                            app(Ys(), l_(X()), Zs()) );
            say_( input(l_(
                        c_("1"), c_("2"), c_("3"), c_("4"), c_("5"),
                        c_("6"), c_("7"), c_("8"), c_("9"), c_("10") )  )
            );

            // goal(Y):-input(X),nrev(X,Y),perm(X,Y),perm(Y,X).
            say_(goal(Y())).
                    if_(    input(X()),
                            nrev(X(), Y()),
                            perm(X(), Y()),
                            perm(Y(), X())  );

            String expected[] = {"[10,9,8,7,6,5,4,3,2,1]"};
            try_it(said, expected);

            Main.println("\n==== TryPerms.test() exiting .... ====");
        }
    }

private class TryJapaneseCode {

        Term   いきる(Term x)      {  return s_("いきる", x);      }
        Term   人()               {  return v_("人");             }
        Term   いいです(Term x)    {  return s_("いいです", x);     }
        Term goal(Term x)         {  return s_("goal", x);       }

    private void test() {
        Main.println("\n==== try_t_J ====");

        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println("\n try_t_J: Construct data structures for try_t_J() case and ...");

        String expected[] = {"私", "あなた"};
        LinkedList<Clause> said = new LinkedList<Clause>();
        for (String s : expected) {
            said.add(Clause.f__( いきる (c_(s))));
        }
        said.add(Clause.f__( いいです ( 人 ())).if_( いきる (人 ())));
        said.add(Clause.f__( goal( 人 ())).if_( いいです ( 人 ())));

        try_it(said, expected);
    }
}

private class TryList {

    private Term zero_and_one(Term x) { return s_("zero_and_one", x); }

    private void test() {
        Main.println("============ TryList.test() entered...");

        Term.reset_gensym();
        Term.set_TarauLog();

        Term l = l_(c0(), c1(), c2());
        assert l != null;
        assert l.is_a_termlist();

        String expected[] = {"[0,1,2]", "[1|0]"};

        LinkedList<Clause> said = new LinkedList<Clause>();

        Clause x;

        // x = Clause.f__("zero_and_one", l);
        x = Clause.f__(zero_and_one(l));
        x.flatten();
        said.add(x);

        x = Clause.f__(zero_and_one(p_(c1(), c0())));
        x.flatten();
        said.add(x);

        x = Clause.f__(goal(V())).if_(zero_and_one(V()));
        x.flatten();
        said.add(x);

        String asm_txt = "";
        for (Clause cl : said) asm_txt += cl.toString() + System.lineSeparator();
        Main.println(asm_txt);

        Prog P = new Prog(asm_txt, false);

        Term.set_Prolog();

        expect_from(P, expected);

        Main.println(" ======== TryList.test() exiting...");
    }
}

private class TryAdd {
        Term  the_sum_of(Term a1, Term a2, Term Sum) {  return s_("the_sum_of", a1,a2,Sum); }
        Term  the_successor_of(Term x) {  return s_("the_successor_of", x); }

    private void test() {
        Main.println("\n ======== TryAdd.test() ====");

        Term.reset_gensym();

        start_new_test();

        Term succ_X = the_successor_of(X());
        Term succ_Z = the_successor_of(Z());
        Term one    = the_successor_of(c0());
        Term vR = v_("R");

        say_( the_sum_of(c0(), X(), X()));
        say_( the_sum_of(succ_X, Y(), succ_Z)).if_(the_sum_of(X(),Y(),Z()));

        Term two = the_successor_of(one);
        say_( goal(vR)).if_(the_sum_of(two, two, vR));

        String[] these_answers = {
                "the_successor_of(the_successor_of(the_successor_of(the_successor_of(0))))"
        };

        try_it(said, these_answers);
        Main.println(" ======== exiting TryAdd.test() . . . ");
    }
}

private class TryQueens { Term QueenColumn()  {  return v_("QueenColumn");    }
    Term Q()            {  return v_("Q");              }
    Term Qs()           {  return v_("Qs");             }
    Term Columns()      {  return v_("Columns");        }
    Term Rows()         {  return v_("Rows");           }
    Term LeftDiags()    {  return v_("LeftDiags");      }
    Term RightDiags()   {  return v_("RightDiags");     }
    Term OtherColumns() {  return v_("OtherColumns");   }
    Term OtherRows()    {  return v_("OtherRows");      }
    Term this_queen_doesnt_fight_in(Term a, Term b, Term c, Term d) {
        return s_("this_queen_doesnt_fight_in", a, b, c, d);
    }
    Term these_queens_dont_fight_on_these_lines(Term a, Term b, Term c, Term d) {
        return s_("these_queens_dont_fight_on_these_lines", a, b, c, d);
    }
    Term these_queens_can_be_in_these_places(Term a, Term b) {
        return s_("these_queens_can_be_in_these_places", a, b);
    }
    Term qs(Term cols, Term rows)  { return s_("qs", cols, rows); }
    Term goal(Term Rows) { return s_("goal", Rows); }

    private void test() {
        Main.println("\n==== TryQueens.test() ====");

        Term.reset_gensym();
        start_new_test();

        say_( this_queen_doesnt_fight_in(
                        QueenColumn(),
                        p_(QueenColumn(), _()),
                        p_(QueenColumn(), _()),
                        p_(QueenColumn(), _())  )
            );
        say_( this_queen_doesnt_fight_in(
                        Q(), p_(_(),Rows()), p_(_(),LeftDiags()), p_(_(),RightDiags()) )
            ).if_(this_queen_doesnt_fight_in(
                        Q(), Rows(), LeftDiags(), RightDiags() )
            );
        say_( these_queens_dont_fight_on_these_lines(
                        l_(), _(), _(), _() )
            );
        say_( these_queens_dont_fight_on_these_lines(
                        p_(QueenColumn(), Qs()),
                        Rows(),
                        LeftDiags(),
                        p_(_(), RightDiags()) )
            ).
            if_(    these_queens_dont_fight_on_these_lines(
                        Qs(), Rows(), p_(_(), LeftDiags()), RightDiags() ),
                    this_queen_doesnt_fight_in(
                        QueenColumn(), Rows(), LeftDiags(), RightDiags() )
            );
        say_( these_queens_can_be_in_these_places(l_(), l_()) );
        say_( these_queens_can_be_in_these_places(
                            p_(_(),OtherColumns()),
                            p_(_(),OtherRows()) )
            ).if_(  these_queens_can_be_in_these_places(
                            OtherColumns(),
                            OtherRows())
            );
        say_( qs(Columns(), Rows())).
            if_(    these_queens_can_be_in_these_places(
                        Columns(),
                        Rows() ),
                    these_queens_dont_fight_on_these_lines(
                        Columns(),Rows(),_(),_() )
            );
        say_( goal(Rows())).
            if_(    qs(l_(c0(),c1(),c2(),c3()),Rows())
            );

        String[] these_answers = {
                "[1,3,0,2]",
                "[2,0,3,1]"
        };
        try_it(said, these_answers);

        Main.println(" ======== exiting TryQueens.test() . . . .");
    }
}

    private void test_gensym() {
        String gs = Term.gensym();
        assert gs.compareTo("_0") == 0;
        String gs1 = Term.gensym();
        assert gs1.compareTo("_1") == 0;
        Term.reset_gensym();
    }

    private Term check_flattening (Term x, Term expected[]) {

        Term.reset_gensym();
        Term r = x.flatten();
        Term.reset_gensym();

        if (expected != null) {
            // assert expected.length == r.size();
            int i = 0;
            for (Term t = r; t != null; t = t.next) {
                Main.println ("Comparing t <<<"+t+">>> to expected["+i+"] <<<"+expected[i]+">>>");
                assert t.is_same_as (expected[i]);
                ++i;
            }
        }

        return r;
    }

    private void test_is_same_as() {
        Term a = c_("a");
        Term a1 = c_("a");

        assert a1.is_same_as(a);
        assert a.is_same_as(a1);

        Term v = v_("X");
        Term v1 = v_("X");
        Term v2 = v_("Y");
        assert (v.is_same_as (v1));
        assert (v1.is_same_as(v));
        assert (!v1.is_same_as(v2));
        assert (!v2.is_same_as(v));

        Term l = l_(a,a1);
        Term l1 = l_(a,a1);
        Term l2 = l_(a,v);
        Main.println ("\n ---------> l is <<<" + l + ">>>, l1 = <<<" + l1 + ">>>");
        assert l.is_same_as(l1);
        Main.println ("\n ---------> l2 is <<<"+l2+" l1 is <<<"+l1+">>>");
        assert l2.is_same_as(l1);

        Term s = s_("foo");
        Term s1 = s_("foo");
        Term s2 = s_("bar");
        Term s3 = s_("bar", s);
        Term s4 = s_("bar", s_("foo"));
        assert s.is_same_as (s1);
        assert !s1.is_same_as (s2);
        assert !s3.is_same_as (s2);
        assert s3.is_same_as (s4);
    }

    private class TestFlatten {
        Term a() { return c_("a"); }
        Term glom(Term x) { return s_("glom", x); }

        private void test() {
            Main.println("\n-----====< TestFlatten.test entered >====-----");

            test_is_same_as();

            // Term a = c_("a");
            Term glom_a = glom(a());
            Term exp0[] = {glom_a};
            check_flattening(glom_a, exp0);

            Term.reset_gensym();
            Term v_0 = v_(Term.gensym());
            Term v_1 = v_(Term.gensym());
            Term v_2 = v_(Term.gensym());

            // quux(blah(a)).
            Main.println("quux(blah(a)).");
            Term blah_a = s_("blah", a());
            Term quux_blah_a = s_("quux", blah_a);
            Term exp1[] = {s_("quux", v_0), e_(v_0, blah_a)};
            check_flattening(quux_blah_a, exp1);

            // whiz([a,a]).
            Main.println ("whiz([a,a]).");
            Term l_a_a = l_(a(), a());
            Term whiz_a_a = s_("whiz", l_a_a);
            Term exp2[] = {s_("whiz", v_0), e_(v_0, l_a_a)};
            check_flattening(whiz_a_a, exp2);

            // foo(bar(X),r).
            Main.println ("foo(bar(X),r).");
            Term bar_X = s_("bar", v_("X"));
            Term foo_bar_X_r = s_("foo", bar_X, c_("r"));
            Term exp3[] = {s_("foo", v_0, c_("r")), e_(v_0, bar_X)};
            check_flattening(foo_bar_X_r, exp3);

            // foo(bar(X),r):-glom(X),quux(blah(X)),whiz([a,a]).
            Main.println ("foo(bar(X),r):-glom(X),quux(blah(X)),whiz([a,a]).");
            Clause cl = Clause.f__("foo", bar_X, c_("r")).
                    if_(s_("glom", v_("X")),
                            s_("quux", s_("blah", v_("X"))),
                            s_("whiz", l_(c_("a"), a())));

            check_flattening(cl.head, exp3);

            // not really checking anything yet
            //for (Term t = cl.body; t != null; t = t.next) {
            //    check_flattening (t, null);
            //}
            check_flattening(cl.body, null);

            Main.println("==== moo ===============================================");

            Term nnn = s_("moo", l_(l_(l_(a()))));

            Term exp5[] = { s_("moo", v_0), e_(v_0,l_(v_1)), e_(v_1,l_(v_2)), e_(v_2,l_(a())) };
            // Term exp5[] = {s_("moo", v_0), e_(v_2, l_(a())), e_(v_1, l_(v_2)), e_(v_0, l_(v_1))};

            check_flattening(nnn, exp5);

            Term mmm = s_("goo", s_("x", s_("y", a())));
            Term exp6[] = {s_("goo", v_0), e_(v_0, s_("x", v_1)), e_(v_1, s_("y", a()))};
            check_flattening(mmm, exp6);

            Main.println("\n-----====< TestFlatten.test... >====-----\n");
        }
    }

    @Test
    public void mainTest() {
        Main.println ("************* Start Term test ********************");

        Term tt = s_("a",c_("b"));
        
        // Term.CustomIterator it = new Term.CustomIterator(tt);
        for (Term x = tt; x != null; x = x.next)
            { Main.println ("!!!!!!!!!!! x = " + x + "!!!!!!!!!!!!!!"); }

        test_gensym();

        String var_X = "X";
        Term vX = v_(var_X);
        assert vX.is_a_variable();

        String const_ooh = "ooh";
        Term cOoh = c_(const_ooh);
        assert cOoh.is_a_constant();

        String cmpnd_fnctr = "compound";
        Term C = s_(cmpnd_fnctr, vX,cOoh);
        assert C != null;
        assert C.is_a_compound();

        Term L = l_(vX,cOoh);
        assert L != null;
        assert L.is_a_termlist();

        new TryBar().test();
        new TrySimple().test();
        new TryList().test();
        new TestFlatten().test();
        new TryT().test();
        new TryAdd().test();
        new TryBig().test();
        new TryPerms().test();
        new TryQueens().test();
        new TryJapaneseCode().test();

        Main.println ("\n======== End Term test ====================");
     
    }
}
