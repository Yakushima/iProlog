package org.iprolog;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertFalse;


import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Arrays;

public class TestTerm {

    static Term v_(String s) {    return Term.variable(s); }
    static Term _()          {    return v_("_");        }
    static Term c_(String s) {    return Term.constant(s); }
    static Term s_(String s) {    return Term.compound(s); }
    static Term s_(String s, Term... ts) {
                                        Term xt = Term.compound(s); 
                                        for (Term t : ts)
                                            xt = xt.takes_this(t);
                                        return xt;
                                    }
    static Term e_(Term lhs, Term rhs) { return Term.equation (lhs,rhs); }
    static Term l_(Term... ts) {
                                        if (ts.length == 0)
                                            return c_("nil");
                                        return Term.termlist(ts);
                                }
    static Term pal_(Term[] tal, int i) {
        if (i == tal.length-2)
            return Term.termpair(tal[i], tal[i+1]);
        return Term.termpair (tal[i], pal_(tal, i+1));
    }
    static Term p_(Term... Ts) { return pal_(Ts, 0);  }

    private Clause yes_ (Term hd) {     return Clause.f__(hd); }

    private String m_() {
        return Thread.currentThread().getStackTrace()[3].getMethodName();
    }
    private String f_() {
        return Thread.currentThread().getStackTrace()[2].getMethodName();
    }

    Term c0() { return c_("0"); }
    Term c1() { return c_("1"); }
    Term c2() { return c_("2"); }
    Term c3() { return c_("3"); }

    Term V()  { return v_(f_()); }
    Term X()  { return v_(f_()); };
    Term Y()  { return v_(f_()); };
    Term Z()  { return v_(f_()); };

    Term Xs() { return v_(f_()); }
    Term Ys() { return v_(f_()); }
    Term Zs() { return v_(f_()); }

    Term goal(Term x)  { return s_(f_(),x); }

    LinkedList<Clause> said;

    private void start_new_test() {
        if (said == null)
            said = new LinkedList<Clause>();
        else
            said.clear();
    }

    private Clause say_(Clause cl) {
        assert said != null;
        said.add (cl);
        return cl;
    }
    private Clause say_(Term hd)   {
        assert said != null;
        Clause cl = yes_(hd);
        said.add (cl);
        return cl;
    }

    /**
   * Initiator and consumer of the stream of answers
   * generated by this engine.
   */
    private void expect_from(Prog P, String[] whats_expected) {
        Object POJO_Ans;

        Term.set_Prolog();

        if (whats_expected != null) {
            Main.println ("whats_expected =");
            for (String s : whats_expected) {
                Main.println ("  Looks like " + s + " when prolog_mode =  " + Term.in_Prolog_mode);
            }
        }

        // Going through the Java Object interface, unfortunately.

        Boolean yielded_something = false;
        while ((POJO_Ans = P.POJO_ask()) != null) {
            yielded_something = true;
            Main.println ("\nIn POJO_ask() loop....");
            assert POJO_Ans instanceof Object[];  // because it'll be "[goal, <answer>]"

            Object[] POJO_goal_answers = (Object[]) POJO_Ans;

            LinkedList<Term> llt = Prog.make_terms_from(POJO_goal_answers);

            assert (llt.size() == 1);
            Term goal_ans = llt.get(0);
            assert goal_ans.is_a_compound();
            assert goal_ans.c().compareTo("goal") == 0;
            Term args = goal_ans.args();

            int i = 0;
            String to_compare = "";
            for (Term t = args; t != null; t = t.next) {
                to_compare += t.toString();
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  goal ["+(i++)+"] = " + t);
            }
 
            String sg = P.showTerm(POJO_goal_answers[0]);
            assert sg.equals("goal");   // because it'll be "[goal, <answer>]"
            assert POJO_goal_answers.length > 1;
            assert POJO_goal_answers.length < 3;
            // Main.println ("POJO_goal_answers[1] is " + POJO_goal_answers[1]);
            String show_POJO_object = P.showTerm(POJO_goal_answers[1]);

            if (whats_expected != null) {
                Prog.println ("  to_compare = " + to_compare);
                Prog.println ("  show_POJO_object = " + show_POJO_object);
                assert Arrays.asList(whats_expected).contains(show_POJO_object);
            } else {
                Main.println (" yielding: " + show_POJO_object);
            }
        }
        assert whats_expected == null || yielded_something;

        Main.println ("... expect_from exiting.");
    }

    private void try_it(LinkedList<Clause> said, String[] whats_expected) {

        assert !said.isEmpty();
        Main.println (" ===== try_it() entering....");
        String s = "[";

        if (whats_expected == null)
            s += "<null>";
        else {  String sep = "";
                for (int i = 0; i < whats_expected.length; ++i) {
                    s += sep;
                    sep = ",";
                    s += whats_expected[i];
                }
        }
        s += "]";
        Main.println ("     whats_expected = " + s);

        String asm_txt;
        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println ("   ===== try_it(): before flatten =======");
        asm_txt = "";
        for (Clause cl : said) {
            asm_txt += cl.toString()+System.lineSeparator();
        }
        Main.println ("asm_txt = \n" + asm_txt);

        Main.println ("   ===== try_it(): flattening transform =======");
        asm_txt = "";
        for (Clause cl : said) {
            cl.flatten();
            asm_txt += cl.toString()+System.lineSeparator();
        }

        Main.println ("   ===== try_it(): Calling new Prog: ===============");
        Prog P = new Prog(asm_txt, false);

        expect_from(P, whats_expected);

        Main.println ("  ===== exiting try_it()");
    }

    private class TryT {
        private  Term good_(Term x)    { return s_(m_(), x); }
        private  Term live_(Term x)    { return s_(m_(), x); }
        private  Term Person()         { return v_(m_());    }

        private void test() {
            Main.println("\n==== TryT.test() entered ... ====");

            start_new_test();

            String expected[] = {"I", "you", "them", "us"};

            for (String s : expected)
                say_(live_(c_(s)));

            say_(good_(Person())).if_(live_(Person()));
            say_(goal(Person())).if_(good_(Person()));

            try_it(said, expected);
        }
    }

private class TrySimple {
    private Term   Foo()            { return  v_(m_());    }
    private Term   dookie(Term x)   { return  s_(m_(), x); }

    private void test() {
        Main.println(" ======== TrySimple.test() entering....");

        start_new_test();

        say_(dookie(l_()));
        say_(dookie(c0()));
        say_(goal(Foo())).if_(dookie(Foo()));

        String expected[] = {"nil", "0"};
        try_it(said, expected);

        Main.println (" ======= TrySimple.test() exiting ....");
    }
};

    private class TryBig {
        Term append(Term this_, Term that, Term result) {
                                              return s_(m_(), this_, that, result);
        }
        Term nrev(Term x, Term y)           { return s_(m_(), x, y); }
        Term dup(Term a, Term b, Term c)    { return s_(m_(), a, b, c); }
        Term next_number_after(Term a, Term a_plus_1) {
                                              return s_(m_(), a, a_plus_1);
        }

        private void test() {  // based on Tarau's original progs/big.pl
            Main.println("\n===== TryBig.test() entering ....");

            start_new_test();

            say_(append(l_(), Ys(), Ys()));
            say_(append(p_(X(), Xs()), Ys(), p_(X(), Zs()))).
                    if_(append(Xs(), Ys(), Zs()));
            say_(nrev(l_(), l_()));
            say_(nrev(p_(X(),Xs()), Zs())).
                    if_(    nrev(Xs(), Ys()),
                            append(Ys(), l_(X()), Zs()));

            for (Integer i = 0; i < 18; ++i) {
                Integer i_next = i + 1;
                say_(next_number_after(c_(i.toString()), c_(i_next.toString())));
            }
            say_(dup(c0(), X(), X()));

            Term R = v_("R");
            Term XX = v_("XX");
            Term N = v_("N");
            Term N1 = v_("N1");
            // dup(N,X,R):-next_number_after(N1,N),append(X,X,XX),dup(N1,XX,R).
            said.add(Clause.f__(dup(N, X(), R)).
                    if_(    next_number_after(N1, N),
                            append(X(), X(), XX),
                            dup(N1, XX, R)));

            // goal([X,Y]):-dup(18,[a,b,c,d],[X,Y|_]).
            Term l_a_b_c_d = l_(c_("a"), c_("b"), c_("c"), c_("d"));

            say_(goal(l_(X(), Y())))
            //        .if_(dup(c_("18"), l_a_b_c_d, l_(X(), p_(Y(), _()))));
            //        .if_(dup(c_("18"), l_a_b_c_d, p_(X(), p_(Y(), _()))));
                    .if_(dup(c_("18"), l_a_b_c_d, p_(X(), Y(), _())));
            String expected[] = {"[a,b]"};
            try_it(said, expected);

            Main.println(" ======== TryBig.test() exiting . . .");
        }
    }

    private class TryBar {
        private Term F()                { return v_(m_());       }
        private Term eq(Term x, Term y) { return s_(m_(), x, y); }
        private Term foo(Term x)        { return s_(m_(), x);    }

        private void test() {

            Main.println("\n==== TryBar.test() (list composition with | symbol) entered ... ====");

            start_new_test();

            say_(eq( X(), X()));
            say_(foo(p_(X(), Y()))).
                    if_(    eq( X(), c1()),
                            eq( Y(), c_("nil")));
            say_(foo(p_(X(), Y()))).
                    if_(    eq( X(), c2()),
                            eq( Y(), c3()));
            say_(foo(l_(X(), Y()))).
                    if_(    eq( X(), c2()),
                            eq( Y(), c3()));
            say_(goal(F())).
                    if_(    foo(F()));

            String expected[] = {"[1]", "[2|3]", "[2,3]"};
            try_it(said, expected);

            Main.println("\n==== TryBar.test() exiting .... ====");
        }
    }

    /*
    Not working, probably because of botches with TermList and TermPair,
    as if a TermList was not a series of TermPairs.....
     */
    class TryMperms {

        private Term G()     {  return v_(m_());     }
        private Term Gs()    {  return v_(m_());    }
        private Term Bs()    {  return v_(m_());    }
        private Term Tail()  {  return v_(m_());  }

        private Term sel(Term a, Term b, Term c) { return s_(m_(), a, b, c); }
        private Term perm(Term x, Term y)        { return s_(m_(), x, y);    }
        private Term input(Term x, Term y)       { return s_(m_(), x, y);    }
        private Term metaint(Term x)             { return s_(m_(), x);       }
        private Term cls(Term x, Term tail)      { return s_(m_(), x, tail); }

        private void test() {
            Main.println("\n==== TryMperms.test() entered ....  ====");

            start_new_test();

    // metaint([]).
            say_( metaint(l_()) );
    //            metaint([  G|  Gs   ]):-    cls([  G|  Bs  ], Gs  ), metaint(Bs  ).
            say_( metaint(p_(G(),Gs()))).if_( cls(p_(G(),Bs()), Gs()), metaint(Bs())) ;

    //            cls([  sel(X,   [  X|  Xs  ], Xs  ) | Tail  ], Tail  ) .
            say_( cls(l_(sel(X(), p_(X(),Xs()), Xs()) , Tail()), Tail()) );

    //            cls([  sel(X,   [  Y|  Xs  ], [  Y|  Ys  ]),    sel(X,  Xs,  Ys  ) |  Tail   ], Tail   ) .
            say_( cls(l_(sel(X(), p_(Y(),Xs()), p_(Y(),Ys())), p_(sel(X(),Xs(),Ys()) ,  Tail())), Tail()) );

    //            cls([  perm([  ],[  ]) | Tail  ], Tail   ) .
            say_( cls(p_(perm(l_(),l_()) , Tail()), Tail() ) );

    //            cls([  perm([     X  |  Xs ], Zs  ), perm(Xs,  Ys  ),    sel(X,  Zs,  Ys  ) | Tail   ], Tail  ) .
    //      say_( cls(l_(perm(l_(p_(X(),Xs())), Zs()), perm(Xs(),Ys()), p_(sel(X(),Zs(),Ys()) , Tail())), Tail()) );

    //      cls([  perm([  X  |Xs  ], Zs  ),    perm(Xs,  Ys  ),    sel(X,  Zs,  Ys  ) | Tail     ], Tail  ) .
      say_( cls(p_(perm(p_(X(),Xs()), Zs()), p_(perm(Xs(),Ys()), p_(sel(X(),Zs(),Ys()) , Tail()) )), Tail()) );
/*
            say_( input (   p_( c_("1"), p_(c_("2"), p_(c_("3"), p_(c_("4"), c_("5") )))) ,
                            p_( c_("5"), p_(c_("4"), p_(c_("3"), p_(c_("2"), c_("1") )))) )
            );
*/
            say_( input (   l_( c_("1"), c_("2")) ,
                            l_( c_("2"), c_("1")) )
            );
    // goal(Y):-input(X,Y),metaint([perm(X,Y),perm(Y,X)]).
            Term lll = metaint(l_(perm(X(),Y()),perm(Y(),X())));
            Main.println ("lll = " + lll);
            lll.flatten();
            Main.println ("lll after flatten = " + lll);
            assert lll.next != null;
            Main.println ("lll.next = " + lll.next);

            say_(goal(Y())).
                    if_(    input(X(),Y()),
                            // metaint(l_(perm(X(),Y()),perm(Y(),X())))     // originally
                            // metaint (l_( c1(),c2()))
                            metaint (l_( perm(X(),Y()),c2()))   // looks OK, generates "_0 lists _1 2"
                            // metaint (l_( perm(X(),Y()),perm(Y(),X())))  // BAD: generates _0 holds list _1 _2
                    );

            String expected[] = { "[5,4,3,2,1]" };
            // try_it(said, expected);
            try_it(said, null);

            Main.println("\n==== TryMperms.test() exiting .... ====");
        }
    }

    class TryPerms {
        private Term eq(Term x, Term y) { return s_("eq", x, y); }

        private Term sel(Term a, Term b, Term c) { return s_(m_(), a, b, c); }
        private Term perm(Term x, Term y)        { return s_(m_(), x, y);    }
        private Term app(Term a, Term b, Term c) { return s_(m_(), a, b, c); }
        private Term nrev(Term x, Term y)        { return s_(m_(), x, y);    }
        private Term input(Term x)               { return s_(m_(), x);       }

        private void test() {
            Main.println("\n==== TryPerms.test() entered ....  ====");

            start_new_test();

            say_( eq(X(), X()) );
            say_( sel(X(), p_(X(), Xs()), Xs()) );
            say_( sel(X(), p_(Y(), Xs()), p_(Y(), Ys()))).
                    if_(    sel(X(), Xs(), Ys()) );
            say_( perm(l_(), l_()) );
            say_( perm(p_(X(), Xs()), Zs())).
                    if_(    perm(Xs(), Ys()),
                            sel(X(), Zs(), Ys()) );
            say_( app(l_(), Xs(), Xs()) );
            say_( app(p_(X(), Xs()), Ys(), p_(X(), Zs()))).
                    if_(app(Xs(), Ys(), Zs()) );
            say_( nrev(l_(), l_()));
            say_( nrev(p_(X(), Xs()), Zs())).
                    if_(    nrev(Xs(), Ys()),
                            app(Ys(), l_(X()), Zs()) );
            say_( input(l_(
                    c_("1"), c_("2"), c_("3"), c_("4"), c_("5"),
                    c_("6"), c_("7"), c_("8"), c_("9"), c_("10") )  )
            );
            say_(goal(Y())).
                    if_(    input(X()),
                            nrev(X(), Y()),
                            perm(X(), Y()),
                            perm(Y(), X())  );

            String expected[] = {"[10,9,8,7,6,5,4,3,2,1]"};
            try_it(said, expected);

            Main.println("\n==== TryPerms.test() exiting .... ====");
        }
    }

private class TryJapaneseCode {

        Term いきる(Term x)   {  return s_(m_(), x);      }
        Term 人()            {  return v_(m_());         }
        Term いいです(Term x) {  return s_(m_(), x);      }
        Term goal(Term x)   {  return s_(m_(), x);      }

    private void test() {
        Main.println("\n==== try_t_J ====");

        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println("\n try_t_J: Construct data structures for try_t_J() case and ...");

        String expected[] = {"私", "あなた"};
        LinkedList<Clause> said = new LinkedList<Clause>();
        for (String s : expected) {
            said.add(Clause.f__( いきる (c_(s))));
        }
        said.add(Clause.f__( いいです ( 人 ())).if_( いきる (人 ())));
        said.add(Clause.f__( goal( 人 ())).if_( いいです ( 人 ())));

        try_it(said, expected);
    }
}

private class TryList {

    private Term zero_and_one(Term x) { return s_(m_(), x); }
    private Term metaint(Term x)      { return s_(m_(), x); }
    private Term perm(Term x )        { return s_(m_(), x); }
    private Term dumb2(Term x, Term y) { return s_(m_(), x, y); }
    private Term dumb3(Term x, Term y) { return s_(m_(), x, y); }

    private void flatten_and_show(Term g) {
        Main.println ("\n     g was " + g);
        g.flatten();
        Main.println ("     after flatten: ");
        for (Term t = g; t != null; t = t.next) {
            Main.println ("                elt = " + t);
        }
        Term.reset_gensym();
    }

    private void test() {
        Main.println("============ TryList.test() entered...");

        Term.reset_gensym();
        Term.set_TarauLog();
// Pattern: second elt of list for metaint is perm(Y)
/*
        flatten_and_show(metaint(l_(c3())));        // OK
        flatten_and_show(metaint(l_(perm(X()))));   // OK
        flatten_and_show(metaint(l_(X())));         // OK
*/
        Main.println("---");
        /*
            flatten_and_show(metaint(l_(c2(), X())));               // OK,  _0 lists 2 X
            flatten_and_show(metaint(l_(c1(), c2())));              // OK
            flatten_and_show(metaint(l_(perm(X()), c2())));         // OK,  _0 lists _1 2
         */
            flatten_and_show(metaint(l_(c2(), perm(X()))));         // BAD: _0 holds list 2 _1
        /*
            flatten_and_show(metaint(l_(perm(X()), perm(Y()))));    // BAD: _0 holds list _1 _2
            flatten_and_show(metaint(l_(perm(c1()), perm(Y()))));    // BAD: _0 holds list _1 _2
            flatten_and_show(metaint(l_(perm(X()), perm(c1()))));    // BAD: _0 holds list _1 _2
            flatten_and_show(metaint(l_(perm(c1()), perm(c2()))));   // BAD: _0 holds list _1 _2
            flatten_and_show(metaint(l_(perm(c1()), c2())));         // OK: _0 lists _1 2
            flatten_and_show(metaint(dumb2(perm(c1()), c2())));         // OK: _0 holds dumb _1 2
            flatten_and_show(metaint(dumb2(perm(c1()), perm(c2()))));   // OK: _0 holds dumb2 _1 _2
        */
        // Pattern?
        //   arg to compound is
        //      2-elt ls
        //      2nd elt of ls is compound


        Main.println("---");
        /*
        flatten_and_show(metaint(l_(c1(), c2(),c3())));              // OK
        flatten_and_show(metaint(l_(perm(X()), c2(), c3())));        // OK
        flatten_and_show(metaint(l_(c2(), c3(), perm(X()))));        // OK
        flatten_and_show(metaint(l_(perm(X()), c3(), perm(Y()))));   // OK
        flatten_and_show(metaint(l_(c2(), c3(), X())));              // OK
        flatten_and_show(metaint(l_(perm(X()), perm(Y()), perm(Y()))));   // OK
        flatten_and_show(metaint(l_(perm(X()), perm(Y()), perm(Y()))));   // OK
         */
        Main.println("---");

        /*
            flatten_and_show((l_(perm(X()), perm(Y()))));   // OK - lists _0 _1
            flatten_and_show((l_(c1(), c2())));             // OK - lists 1 2
            flatten_and_show((l_(perm(X()), c2())));        // OK - lists _0 2
            flatten_and_show((l_(c2(), perm(X()))));        // OK - lists 2 _0
            flatten_and_show((l_(perm(X()), perm(Y()))));   // OK - lists _0 _1
            flatten_and_show((l_(c2(), X())));              // OK - lists 2 X
        */
        Term l = l_(c0(), c1(), c2());
        assert l != null;
        assert l.is_a_termlist();

        String expected[] = {"[0,1,2]", "[1|0]"};

        LinkedList<Clause> said = new LinkedList<Clause>();

        Clause x;

        // x = Clause.f__("zero_and_one", l);
        x = Clause.f__(zero_and_one(l));
        x.flatten();
        said.add(x);

        x = Clause.f__(zero_and_one(p_(c1(), c0())));
        x.flatten();
        said.add(x);

        x = Clause.f__(goal(V())).if_(zero_and_one(V()));
        x.flatten();
        said.add(x);

        String asm_txt = "";
        for (Clause cl : said) asm_txt += cl.toString() + System.lineSeparator();
        Main.println(asm_txt);

        Prog P = new Prog(asm_txt, false);

        Term.set_Prolog();

        expect_from(P, expected);



        Main.println(" ======== TryList.test() exiting...");
    }
}

private class TryAdd {
        Term  the_sum_of(Term a1, Term a2, Term Sum)    {  return s_(m_(), a1,a2,Sum);  }
        Term  the_successor_of(Term x)                  {  return s_(m_(), x);          }

    private void test() {
        Main.println("\n ======== TryAdd.test() ====");

        Term.reset_gensym();

        start_new_test();

        Term succ_X = the_successor_of(X());
        Term succ_Z = the_successor_of(Z());
        Term one    = the_successor_of(c0());
        Term vR = v_("R");

        say_( the_sum_of(c0(), X(), X()));
        say_( the_sum_of(succ_X, Y(), succ_Z)).if_(the_sum_of(X(),Y(),Z()));

        Term two = the_successor_of(one);
        say_( goal(vR)).if_(the_sum_of(two, two, vR));

        String[] these_answers = {
                "the_successor_of(the_successor_of(the_successor_of(the_successor_of(0))))"
        };

        try_it(said, these_answers);
        Main.println(" ======== exiting TryAdd.test() . . . ");
    }
}

private class TryQueens {
    Term QueenColumn()  {  return v_("QueenColumn");    }
    Term Q()            {  return v_(m_());                }
    Term Qs()           {  return v_(m_());                }
    Term Columns()      {  return v_(m_());                }
    Term Rows()         {  return v_(m_());                }
    Term LeftDiags()    {  return v_(m_());                }
    Term RightDiags()   {  return v_(m_());                }
    Term OtherColumns() {  return v_(m_());                }
    Term OtherRows()    {  return v_(m_());                }

    Term this_queen_doesnt_fight_in(Term a, Term b, Term c, Term d) {
                                      return s_(m_(), a, b, c, d);
    }
    Term these_queens_dont_fight_on_these_lines(Term a, Term b, Term c, Term d) {
                                      return s_(m_(), a, b, c, d);
    }
    Term these_queens_can_be_in_these_places(Term a, Term b) {
                                      return s_(m_(), a, b);
    }
    Term qs(Term cols, Term rows)   { return s_(m_(), cols, rows); }
    Term goal(Term Rows)            { return s_(m_(), Rows); }

    private void test() {
        Main.println("\n==== TryQueens.test() ====");

        Term.reset_gensym();
        start_new_test();

        say_( this_queen_doesnt_fight_in(
                        QueenColumn(),
                        p_(QueenColumn(), _()),
                        p_(QueenColumn(), _()),
                        p_(QueenColumn(), _())  )
            );
        say_( this_queen_doesnt_fight_in(
                        Q(), p_(_(),Rows()), p_(_(),LeftDiags()), p_(_(),RightDiags()) )
            ).if_(this_queen_doesnt_fight_in(
                        Q(), Rows(), LeftDiags(), RightDiags() )
            );
        say_( these_queens_dont_fight_on_these_lines(
                        l_(), _(), _(), _() )
            );
        say_( these_queens_dont_fight_on_these_lines(
                        p_(QueenColumn(), Qs()),
                        Rows(),
                        LeftDiags(),
                        p_(_(), RightDiags()) )
            ).
            if_(    these_queens_dont_fight_on_these_lines(
                        Qs(), Rows(), p_(_(), LeftDiags()), RightDiags() ),
                    this_queen_doesnt_fight_in(
                        QueenColumn(), Rows(), LeftDiags(), RightDiags() )
            );
        say_( these_queens_can_be_in_these_places(l_(), l_()) );
        say_( these_queens_can_be_in_these_places(
                            p_(_(),OtherColumns()),
                            p_(_(),OtherRows()) )
            ).if_(  these_queens_can_be_in_these_places(
                            OtherColumns(),
                            OtherRows())
            );
        say_( qs(Columns(), Rows())).
            if_(    these_queens_can_be_in_these_places(
                        Columns(),
                        Rows() ),
                    these_queens_dont_fight_on_these_lines(
                        Columns(),Rows(),_(),_() )
            );
        say_( goal(Rows())).
            if_(    qs(l_(c0(),c1(),c2(),c3()),Rows())
            );

        String[] these_answers = {
                "[1,3,0,2]",
                "[2,0,3,1]"
        };
        try_it(said, these_answers);

        Main.println(" ======== exiting TryQueens.test() . . . .");
    }
}

    Term v_() { return v_(m_()); }

private class Funny {
        private Term voodoo() { return v_(); }

        String prove() {
            return "voodoo() called from class method yields " + voodoo();
        }

}

    private class TryLambdas {

        Term Vs()           {  return v_(m_());                }
        Term N()            {  return v_(m_());                }
        Term A()            {  return v_(m_());                }
        Term B()            {  return v_(m_());                }
        Term T()            {  return v_(m_());                }
        Term L()            {  return v_(m_());                }
        Term N1()           {  return v_(m_());                }
        Term N2()           {  return v_(m_());                }
        Term N3()           {  return v_(m_());                }
        Term Lam()          {  return v_(m_());                }
        Term Size()         {  return v_(m_());                }

        Term zero()         {  return c_(m_());                }

        Term l(Term a, Term b)        { return s_(m_(), a,b);    }
        Term s(Term a)                { return s_(m_(), a);      }
        Term a(Term x, Term y)        { return s_(m_(), x,y);    }

        Term genLambda(Term a, Term b, Term c, Term d)
                                      { return s_(m_(),a,b,c,d); }
        Term memb(Term a,Term b)      { return s_(m_(), a,b);    }
        Term genClosedLambdaTerm(Term L, Term T)
                                      { return s_(m_(), L,T);    }
        Term some(Term x)             { return s_(m_(), x);      }

        Term goal(Term Lam)           { return s_(m_(), Lam);    }

        private void test() {

            Main.println("\n==== TryLambdas.test() ====");

            Term.reset_gensym();
            start_new_test();

            //   genLambda(X  ,Vs,  N  ,N   ) :- memb(X,Vs).
            say_(genLambda(X(),Vs(),N(),N()))
                    .if_(   memb(X(),Vs())  );

            //   genLambda(l(X,  A  ), Vs  ,s(N1  ),N2):-genLambda(A,[X|Vs],N1,N2).
            say_(genLambda(l(X(),A()), Vs(),s(N1()),N2()))
                    .if_(   genLambda(A(),p_(X(),Vs()),N1(),N2())  );

            //   genLambda(a(A,  B  ), Vs,   s(N1),  N3):-genLambda(A,Vs,N1,N2),genLambda(B,Vs,N2,N3).
            say_(genLambda(a(A(),B()), Vs(), s(N1()),N3()))
                    .if_(   genLambda(A(),Vs(),N1(),N2()),
                            genLambda(B(),Vs(),N2(),N3())  );

            // memb(X,[X|_]).
            say_(memb(X(),p_(X(),_())));

            //   memb(X,  [  _|  Xs])  :- memb(X,Xs).
            say_(memb(X(),p_(_(),Xs())))
                    .if_(   memb(X(),Xs())  );

            //   genClosedLambdaTerm(L,  T   ) :-genLambda(T,[],L,zero).
            say_(genClosedLambdaTerm(L(),T()))
                    .if_(   genLambda(T(),l_(),L(),zero())  );

            // % nine(s(s(s(s(s(s(s(s(s(zero)))))))))).

            //   some((s(s(zero)))).
            say_(some(s(s(zero()))));

            // goal(Lam):-some(Size),genClosedLambdaTerm(Size,Lam).
            say_(goal(Lam()))
                    .if_(   some(Size()),
                            genClosedLambdaTerm(Size(),Lam()) );

            String[] these_answers = {
                    "l(V134,l(V157,V157))",
                    "l(V134,l(V157,V134))",
                    "l(V134,a(V134,V134))"
            };
            // try_it(said, these_answers);
            try_it(said, null);

            Main.println(" ======== exiting TryQueens.test() . . . .");
        }
    }

    private void test_gensym() {
        String gs = Term.gensym();
        assert gs.compareTo("_0") == 0;
        String gs1 = Term.gensym();
        assert gs1.compareTo("_1") == 0;
        Term.reset_gensym();
    }

    private Term check_flattening (Term x, Term expected[]) {

        Term.reset_gensym();
        Term r = x.flatten();
        Term.reset_gensym();

        if (expected != null) {
            // assert expected.length == r.size();
            int i = 0;
            for (Term t = r; t != null; t = t.next) {
                Main.println ("Comparing t <<<"+t+">>> to expected["+i+"] <<<"+expected[i]+">>>");
                assert t.is_same_as (expected[i]);
                ++i;
            }
        }

        return r;
    }

    private void test_is_same_as() {
        Term a = c_("a");
        Term a1 = c_("a");

        assert a1.is_same_as(a);
        assert a.is_same_as(a1);

        Term v = v_("X");
        Term v1 = v_("X");
        Term v2 = v_("Y");
        assert (v.is_same_as (v1));
        assert (v1.is_same_as(v));
        assert (!v1.is_same_as(v2));
        assert (!v2.is_same_as(v));

        Term l = l_(a,a1);
        Term l1 = l_(a,a1);
        Term l2 = l_(a,v);
        Main.println ("\n ---------> l is <<<" + l + ">>>, l1 = <<<" + l1 + ">>>");
        assert l.is_same_as(l1);
        Main.println ("\n ---------> l2 is <<<"+l2+" l1 is <<<"+l1+">>>");
        assert l2.is_same_as(l1);

        Term s = s_("foo");
        Term s1 = s_("foo");
        Term s2 = s_("bar");
        Term s3 = s_("bar", s);
        Term s4 = s_("bar", s_("foo"));
        assert s.is_same_as (s1);
        assert !s1.is_same_as (s2);
        assert !s3.is_same_as (s2);
        assert s3.is_same_as (s4);
    }

    private class TestFlatten {
        Term a()            { return c_(m_());    }
        Term glom(Term x)   { return s_(m_(), x); }

        private void test() {
            Main.println("\n-----====< TestFlatten.test entered >====-----");

            test_is_same_as();

            // Term a = c_("a");
            Term glom_a = glom(a());
            Term exp0[] = {glom_a};
            check_flattening(glom_a, exp0);

            Term.reset_gensym();
            Term v_0 = v_(Term.gensym());
            Term v_1 = v_(Term.gensym());
            Term v_2 = v_(Term.gensym());

            // quux(blah(a)).
            Main.println("quux(blah(a)).");
            Term blah_a = s_("blah", a());
            Term quux_blah_a = s_("quux", blah_a);
            Term exp1[] = {s_("quux", v_0), e_(v_0, blah_a)};
            check_flattening(quux_blah_a, exp1);

            // whiz([a,a]).
            Main.println ("whiz([a,a]).");
            Term l_a_a = l_(a(), a());
            Term whiz_a_a = s_("whiz", l_a_a);
            Term exp2[] = {s_("whiz", v_0), e_(v_0, l_a_a)};
            check_flattening(whiz_a_a, exp2);

            // foo(bar(X),r).
            Main.println ("foo(bar(X),r).");
            Term bar_X = s_("bar", v_("X"));
            Term foo_bar_X_r = s_("foo", bar_X, c_("r"));
            Term exp3[] = {s_("foo", v_0, c_("r")), e_(v_0, bar_X)};
            check_flattening(foo_bar_X_r, exp3);

            // foo(bar(X),r):-glom(X),quux(blah(X)),whiz([a,a]).
            Main.println ("foo(bar(X),r):-glom(X),quux(blah(X)),whiz([a,a]).");
            Clause cl = Clause.f__("foo", bar_X, c_("r")).
                    if_(s_("glom", v_("X")),
                            s_("quux", s_("blah", v_("X"))),
                            s_("whiz", l_(c_("a"), a())));

            check_flattening(cl.head, exp3);

            // not really checking anything yet
            //for (Term t = cl.body; t != null; t = t.next) {
            //    check_flattening (t, null);
            //}
            check_flattening(cl.body, null);

            Main.println("==== moo ===============================================");

            Term nnn = s_("moo", l_(l_(l_(a()))));

            Term exp5[] = { s_("moo", v_0), e_(v_0,l_(v_1)), e_(v_1,l_(v_2)), e_(v_2,l_(a())) };
            // Term exp5[] = {s_("moo", v_0), e_(v_2, l_(a())), e_(v_1, l_(v_2)), e_(v_0, l_(v_1))};

            check_flattening(nnn, exp5);

            Term mmm = s_("goo", s_("x", s_("y", a())));
            Term exp6[] = {s_("goo", v_0), e_(v_0, s_("x", v_1)), e_(v_1, s_("y", a()))};
            check_flattening(mmm, exp6);

            Main.println("\n-----====< TestFlatten.test... >====-----\n");
        }
    }

    @Test
    public void mainTest() {
        Main.println ("************* Start Term test ********************");

        Term tt = s_("a",c_("b"));
        
        // Term.CustomIterator it = new Term.CustomIterator(tt);
        for (Term x = tt; x != null; x = x.next)
            { Main.println ("!!!!!!!!!!! x = " + x + "!!!!!!!!!!!!!!"); }

        test_gensym();

        String var_X = "X";
        Term vX = v_(var_X);
        assert vX.is_a_variable();

        String const_ooh = "ooh";
        Term cOoh = c_(const_ooh);
        assert cOoh.is_a_constant();

        String cmpnd_fnctr = "compound";
        Term C = s_(cmpnd_fnctr, vX,cOoh);
        assert C != null;
        assert C.is_a_compound();

        Term L = l_(vX,cOoh);
        assert L != null;
        assert L.is_a_termlist();

        Term xxx = l_(c0(),c1(),c2());
        Main.println ("xxx = " + xxx);
        for (Term t = xxx; t != null; t = t.next)
            Main.println ("   >>>>>>> " + t);
        Term yyy = p_(xxx,c3());

        new TryBar().test();
        new TrySimple().test();
        new TryList().test();
        new TestFlatten().test();
        new TryT().test();
        new TryMperms().test();
        new TryAdd().test();
        new TryPerms().test();
        new TryQueens().test();
        new TryJapaneseCode().test();

        new TryBig().test();
        new TryLambdas().test();

        Main.println ("voodoo = " + new Funny().prove());

        Main.println ("\n======== End Term test ====================");
    }
}
