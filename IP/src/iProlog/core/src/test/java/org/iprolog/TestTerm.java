package org.iprolog;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertFalse;


import java.util.LinkedList;
import java.util.Arrays;

public class TestTerm {

    private static Term v_(String s) { return Term.variable(s); }
    private static Term c_(String s) { return Term.constant(s); }
    private static Term s_(String s) { return Term.compound(s); }
    private static Term s_(String s, Term... ts) {
                                        Term xt = Term.compound(s); 
                                        for (Term t : ts)
                                            xt.takes_this(t);
                                        return xt;
                                    }
    private static Term s_(String s, LinkedList<Term> llt) { return Term.compound(s,llt); }
    private static Term e_(Term lhs, Term rhs) { return Term.equation (lhs,rhs); }

    /**
   * Initiator and consumer of the stream of answers
   * generated by this engine.
   */
    private void expect_from(Prog P, String[] whats_expected) {
        Object A;

        Main.println ("///////////// Entering expect_from /////////////");
        Main.println ("whats_expected =");
        for (String s : whats_expected) {
            Main.println ("  " + s);
        }

        Main.println ("Entering expect_from loop:");

        while ((A = P.ask()) != null) {
            assert A instanceof Object[];  // because it'll be "[goal, <answer>]"
            Object[] oa = (Object[]) A;

              //////////////////////////////////////////////
             // This currently retains c__ and V__ prefixes:
            //
            LinkedList<Term> llt = Prog.make_terms_from(oa);

              //////////////////////////////////////////////
             // Some of the asserts here will bomb for queries with tuple
            // return values; punting for now.

            Prog.println ("  llt = " + llt.toString());
            Prog.println ("  llt.size() = " + llt.size());
            assert (llt.size() == 1);
            Term x = llt.get(0);
            Prog.println ("  x = " + x.toString());
            assert x.is_a_compound();
            Prog.println ("  x.c  = " + x.c);
            assert x.c.compareTo("goal") == 0;
            LinkedList<Term> args = x.args();
            Prog.println ("  args = " + args.toString());
            Prog.println ("  args.size() = " + args.size());
            assert args.size() == 1;
            Term a = args.get(0);
            Prog.println ("  a = " + a.toString()); 

            String s1 = P.showTerm(oa[0]);
            assert s1.equals("goal");   // because it'll be "[goal, <answer>]"
            assert oa.length > 1;
            String so = P.showTerm(oa[1]);

            if (whats_expected != null) {
                Main.println ("  +++ so = " + so);
                assert Arrays.asList(whats_expected).contains(so);
            }
        }
    }

    private void try_t() {
        Main.println ("\n==== try_t ====");
        /*
         * live_(i_).
         * live_(you_).
         * good_(Person) :- live_(Person).
         * goal(Person):-good_(Person).
         * 
                * live_ i_ .
                * live_ you_ .
                * good_ Person
                * if
                *   live_ Person .
                *
                * goal Person
                * if
                *   good_ Person .

         */

        Term.reset_gensym();
        Term.set_TarauLog();

        Main.println ("\n Construct data structures for try_t() case and ...");

        String expected[] = {"I", "you"};

        Term vPerson = v_("person");

        LinkedList<Clause> llc = new LinkedList<Clause>();

        for (String s : expected)
            llc.add (Clause.f__("live_", c_(s)));

        llc.add (Clause.f__("good_", vPerson).if__(s_("live_", vPerson)));
        llc.add (Clause.f__("goal",  vPerson).if__(s_("good_", vPerson)));

        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Prog P = new Prog(x_out, false);

        Term.set_Prolog();
        Main.println ("\n=== Pretty-print Prolog from it ===");

        P.ppCode();
        expect_from(P, expected);
    }

    private void try_add() {
        Main.println ("\n==== try_add() ====");
        /*
        the_sum_of(0,X,X).
        the_sum_of(the_successor_of(X),Y,the_successor_of(Z)):-the_sum_of(X,Y,Z).
        goal(R):-
         the_sum_of(the_successor_of(the_successor_of(0)),the_successor_of(the_successor_of(0)),R).

            the_sum_of 0 X X .

            the_sum_of _0 Y _1 and
              _0 holds the_successor_of X and
              _1 holds the_successor_of Z
            if
            the_sum_of X Y Z .

            goal R
            if
              the_sum_of _0 _1 R and
              _0 holds the_successor_of _2 and
              _2 holds the_successor_of 0 and
              _1 holds the_successor_of _3 and
              _3 holds the_successor_of 0 .
         */

        // out = "";
        Term.reset_gensym();

        LinkedList<Clause> llc = new LinkedList<Clause>();
        Term vX = v_("X");
        Term vY = v_("Y");
        Term vZ = v_("Z");
        Term c0 = c_("0");
        Term succ_X = s_("the_successor_of", vX);
        Term succ_Z = s_("the_successor_of", vZ);
        Term succ_0 = s_("the_successor_of", c0);

        llc.add(Clause.f__("the_sum_of", c0, vX, vX));
        // llc.add(Clause.f__("the_sum_of", succ_X,vY,succ_Z).if__(s_("the_sum_of",vX,vY,vZ)));

        Main.println ("\n=== Try adding 2+2 in unary, generating TarauLog ===");

        Term.set_TarauLog();

        Clause f = Clause.f__("the_sum_of", succ_X, vY, succ_Z);
        assert f.head.size() == 1;
        f.head = f.head.peekFirst().flatten();
        Main.println ("f.head = " + f.head.toString());
        f = f.if__(s_("the_sum_of", vX, vY, vZ));
        Main.println("f.toString() = " + f.toString());
        llc.add(f);

            // goal(R):-
            //  the_sum_of(the_successor_of(the_successor_of(0)),the_successor_of(the_successor_of(0)),R).
            
        Term vR = v_("R");
        Clause g = Clause.f__("goal", vR);
        Term s_of_s_of_0 = s_("the_successor_of", succ_0);
        g.if__(s_("the_sum_of", s_of_s_of_0, s_of_s_of_0, vR));
        Main.println ("g.toString() = " + g.toString());
        LinkedList<Term> g_flat = g.body.peekFirst().flatten();
        g.body = g_flat;
        llc.add(g);

        Main.println ("----- Clause.f__ construction: --------");
        String x_out = "";
        for (Clause cl : llc)  x_out += cl.toString()+"\n";
        Main.println (x_out);

        Prog P = new Prog(x_out, false);

        Main.println ("\n=== Pretty-print as Prolog ===");
        Term.set_Prolog();
        P.ppCode();
        
        Main.println ("\n===<<< Starting to run >>>===");

        String[] these_answers = {
            "the_successor_of(the_successor_of(the_successor_of(the_successor_of(0))))"
        };

        expect_from(P, these_answers);
    }

    @Test
    public void mainTest() {
        Main.println ("************* Start Term test ********************");
      
        String gs = Term.gensym();
        assert gs.compareTo("_0") == 0;
        String gs1 = Term.gensym();
        assert gs1.compareTo("_1") == 0;
        Term.reset_gensym();

        String var_s = "X";
        String const_s = "ooh";
        String cmpnd_fnctr = "compound";
        String cmpnd_fnctr1 = "compendium";

        Term v = v_(var_s);
        assert v.is_a_variable();

        Term c = c_(const_s);
        assert c.is_a_constant();

        LinkedList<Term> tl = new LinkedList<Term>();
        tl.add(v);
        tl.add(c);
        Term C = s_(cmpnd_fnctr, tl);
        assert C.is_a_compound();

        // Main.println ("C=" + C);
        String CC = cmpnd_fnctr + "(" + var_s + "," + const_s + ")";
        assert C.toString().compareTo(CC.toString()) == 0;

        LinkedList<Term> fv = v.flatten();
        assert fv.size() == 1;
        assert fv.peekFirst().v == v.v;

        LinkedList<Term> fc = c.flatten();
        assert fc.size() == 1;
        assert fc.peekFirst().c == c.c;

        LinkedList<Term> fC = C.flatten();
        assert fC.size() == 1;
        assert fC.peekFirst().c == C.c;
        // Main.println ("Term C = " + C + ", C.is_flat()=" + C.is_flat());

        Term C1 = s_ (cmpnd_fnctr1);
        assert C1.is_a_compound();
        C1.takes_this (C);
        LinkedList<Term> fC1 = C1.flatten();
        // Main.println ("fC1.size() = " + fC1.size());
        // for (Term t : fC1) Main.println ("a flattened term t=" + t + ", t.is_flat()=" + t.is_flat());

        Term eqn1 = e_ (v,c);
        assert eqn1 != null;

        // Main.println ("eqn1 = " + eqn1);

        Term v1 = v_("Y");
        assert v1.is_a_variable();

        LinkedList<Term> lC1 = new LinkedList<Term>();
        lC1.add(C1);
        Term C2 = s_("foo",lC1);
        // Main.println ("\n\n\nC2 = " + C2 + ", C2.is_flat() = " + C2.is_flat());

        Term eqn2 = e_ (v1, C2);
        // Main.println ("eqn2 = " + eqn2 + ", eqn2.is_flat() = " + eqn2.is_flat());

        LinkedList<Term> flatcat = eqn2.flatten();
        // Main.println ("Flattened: ");
        // for (Term t : flatcat) Main.println ("  -- " + t);

        Main.println ("-----------------------------------------");

        String sum = "the_sum_of";
        String s = "the_successor_of";
        Term an_X = v_("X");
        Term a_Y  = v_("Y");
        Term s_of_X = s_ (s, an_X);
        Term s_of_Y = s_ (s, a_Y);
        LinkedList<Term> lll = new LinkedList<Term>();
        lll.add(s_of_X);
        lll.add(an_X);
        lll.add(s_of_Y);
        Term summer_head = s_(sum,lll);

        // Main.println ("summer_head = "+ summer_head);

        LinkedList<Term> flattery = summer_head.flatten();
        // for (Term t : flattery) Main.println ("flattery has " + t);

        try_t();
        try_add();

        Main.println ("\n======== End Term test ====================");
    }
}
